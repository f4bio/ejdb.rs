/* automatically generated by rust-bindgen */

pub const INVALID_HANDLE_VALUE: i32 = -1;
pub const IW_ERROR_START: u32 = 70000;
pub const IW_PATH_CHR: u8 = 47u8;
pub const IW_PATH_STR: &'static [u8; 2usize] = b"/\0";
pub const IW_LINE_SEP: &'static [u8; 2usize] = b"\n\0";
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const _SYS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const IWCPU_SSE: u32 = 1;
pub const IWCPU_SSE2: u32 = 2;
pub const IWCPU_SSE3: u32 = 4;
pub const IWCPU_SSE4_1: u32 = 8;
pub const IWCPU_SSE4_2: u32 = 16;
pub const IWCPU_AVX: u32 = 32;
pub const IWCPU_AVX2: u32 = 64;
pub const IWCPU_AVX512F: u32 = 128;
pub const IWFS_DEFAULT_FILEMODE: u32 = 438;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const IWFSM_MAGICK: u32 = 27051980;
pub const IWFSM_CUSTOM_HDR_DATA_OFFSET: u32 = 77;
pub const IWKV_MAX_KVSZ: u32 = 268435455;
pub const IWKVD_PRINT_NO_LEVEVELS: u32 = 1;
pub const IWKVD_PRINT_VALS: u32 = 2;
pub const IWPOOL_POOL_SIZ: u32 = 8192;
pub const EJDB_COLLECTION_NAME_MAX_LEN: u32 = 255;
pub type HANDLE = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[doc = " @brief The operation result status code."]
#[doc = ""]
#[doc = " Zero status code `0` indicates <em>operation success</em>"]
#[doc = ""]
#[doc = " Status code can embed an `errno` code as operation result."]
#[doc = " In this case `uint32_t iwrc_strip_errno(iwrc *rc)` used"]
#[doc = " to fetch embedded errno."]
#[doc = ""]
#[doc = " @see iwlog.h"]
pub type iwrc = u64;
#[doc = " @brief A rational number."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IW_RNUM {
    #[doc = "< Numerator"]
    pub n: i32,
    #[doc = "< Denometator"]
    pub dn: i32,
}
#[test]
fn bindgen_test_layout_IW_RNUM() {
    assert_eq!(
        ::std::mem::size_of::<IW_RNUM>(),
        8usize,
        concat!("Size of: ", stringify!(IW_RNUM))
    );
    assert_eq!(
        ::std::mem::align_of::<IW_RNUM>(),
        4usize,
        concat!("Alignment of ", stringify!(IW_RNUM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IW_RNUM>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IW_RNUM),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IW_RNUM>())).dn as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IW_RNUM),
            "::",
            stringify!(dn)
        )
    );
}
extern "C" {
    #[doc = " @brief Init iowow subsystem."]
    #[doc = " @return `0` on success or error code."]
    pub fn iw_init() -> iwrc;
}
extern "C" {
    pub fn iowow_version_full() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn iowow_version_major() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn iowow_version_minor() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn iowow_version_patch() -> ::std::os::raw::c_uint;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        96usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        8usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).decimal_point as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).thousands_sep as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).grouping as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_curr_symbol as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).currency_symbol as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_decimal_point as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_thousands_sep as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_grouping as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).positive_sign as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).negative_sign as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_frac_digits as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).frac_digits as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_cs_precedes as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sep_by_space as *const _ as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_cs_precedes as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sep_by_space as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sign_posn as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sign_posn as *const _ as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_cs_precedes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sep_by_space as *const _ as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_cs_precedes as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sep_by_space as *const _ as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sign_posn as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sign_posn as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
extern "C" {
    pub fn setlocale(
        __category: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn newlocale(
        __category_mask: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
        __base: locale_t,
    ) -> locale_t;
}
extern "C" {
    pub fn duplocale(__dataset: locale_t) -> locale_t;
}
extern "C" {
    pub fn freelocale(__dataset: locale_t);
}
extern "C" {
    pub fn uselocale(__dataset: locale_t) -> locale_t;
}
#[doc = "< No error."]
pub const iw_ecode_IW_OK: iw_ecode = 0;
#[doc = "< Unspecified error."]
pub const iw_ecode_IW_ERROR_FAIL: iw_ecode = 70000;
#[doc = "< Error with expected errno status set."]
pub const iw_ecode_IW_ERROR_ERRNO: iw_ecode = 70001;
#[doc = "< IO error with expected errno status set."]
pub const iw_ecode_IW_ERROR_IO_ERRNO: iw_ecode = 70002;
pub const iw_ecode_IW_ERROR_AGAIN: iw_ecode = 70003;
#[doc = "< Resource is not exists."]
pub const iw_ecode_IW_ERROR_NOT_EXISTS: iw_ecode = 70004;
#[doc = "< Resource is readonly."]
pub const iw_ecode_IW_ERROR_READONLY: iw_ecode = 70005;
#[doc = "< Resource is already opened."]
pub const iw_ecode_IW_ERROR_ALREADY_OPENED: iw_ecode = 70006;
#[doc = "< Threading error."]
pub const iw_ecode_IW_ERROR_THREADING: iw_ecode = 70007;
#[doc = "< Threading error with errno status set."]
pub const iw_ecode_IW_ERROR_THREADING_ERRNO: iw_ecode = 70008;
#[doc = "< Generic assertion error."]
pub const iw_ecode_IW_ERROR_ASSERTION: iw_ecode = 70009;
#[doc = "< Invalid HANDLE value."]
pub const iw_ecode_IW_ERROR_INVALID_HANDLE: iw_ecode = 70010;
#[doc = "< Invalid bounds specified."]
pub const iw_ecode_IW_ERROR_OUT_OF_BOUNDS: iw_ecode = 70011;
#[doc = "< Method is not implemented."]
pub const iw_ecode_IW_ERROR_NOT_IMPLEMENTED: iw_ecode = 70012;
#[doc = "< Memory allocation failed."]
pub const iw_ecode_IW_ERROR_ALLOC: iw_ecode = 70013;
#[doc = "< Illegal state error."]
pub const iw_ecode_IW_ERROR_INVALID_STATE: iw_ecode = 70014;
#[doc = "< Argument is not aligned properly."]
pub const iw_ecode_IW_ERROR_NOT_ALIGNED: iw_ecode = 70015;
#[doc = "< Request rejection/false response."]
pub const iw_ecode_IW_ERROR_FALSE: iw_ecode = 70016;
#[doc = "< Invalid function arguments."]
pub const iw_ecode_IW_ERROR_INVALID_ARGS: iw_ecode = 70017;
#[doc = "< Overflow."]
pub const iw_ecode_IW_ERROR_OVERFLOW: iw_ecode = 70018;
#[doc = "< Invalid value."]
pub const iw_ecode_IW_ERROR_INVALID_VALUE: iw_ecode = 70019;
#[doc = "< Unexpected response (IW_ERROR_UNEXPECTED_RESPONSE)"]
pub const iw_ecode_IW_ERROR_UNEXPECTED_RESPONSE: iw_ecode = 70020;
#[doc = "< Action is not allowed. (IW_ERROR_NOT_ALLOWED)"]
pub const iw_ecode_IW_ERROR_NOT_ALLOWED: iw_ecode = 70021;
#[doc = "< Unsupported opration. (IW_ERROR_UNSUPPORTED)"]
pub const iw_ecode_IW_ERROR_UNSUPPORTED: iw_ecode = 70022;
#[doc = " @enum iw_ecode"]
#[doc = " @brief Common used error codes."]
pub type iw_ecode = u32;
pub const iwlog_lvl_IWLOG_ERROR: iwlog_lvl = 0;
pub const iwlog_lvl_IWLOG_WARN: iwlog_lvl = 1;
pub const iwlog_lvl_IWLOG_INFO: iwlog_lvl = 2;
pub const iwlog_lvl_IWLOG_DEBUG: iwlog_lvl = 3;
#[doc = " @enum iwlog_lvl"]
#[doc = " @brief Available logging vebosity levels."]
pub type iwlog_lvl = u32;
#[doc = " @brief Options for the default logging function."]
#[doc = " @see iwlog_set_logfn_opts(void*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWLOG_DEFAULT_OPTS {
    #[doc = "< Output file stream. Default: `stderr`"]
    pub out: *mut FILE,
}
#[test]
fn bindgen_test_layout_IWLOG_DEFAULT_OPTS() {
    assert_eq!(
        ::std::mem::size_of::<IWLOG_DEFAULT_OPTS>(),
        8usize,
        concat!("Size of: ", stringify!(IWLOG_DEFAULT_OPTS))
    );
    assert_eq!(
        ::std::mem::align_of::<IWLOG_DEFAULT_OPTS>(),
        8usize,
        concat!("Alignment of ", stringify!(IWLOG_DEFAULT_OPTS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWLOG_DEFAULT_OPTS>())).out as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWLOG_DEFAULT_OPTS),
            "::",
            stringify!(out)
        )
    );
}
#[doc = " @brief Logging function pointer."]
#[doc = ""]
#[doc = " @param locale Locale used to print error message."]
#[doc = " @param lvl Log level."]
#[doc = " @param ecode Error code specified."]
#[doc = " @param errno_code Optional errno code. Set it to 0 if errno not used."]
#[doc = " @param file File name. Can be `NULL`"]
#[doc = " @param line Line number in the file."]
#[doc = " @param ts Message time-stamp"]
#[doc = " @param fmt `printf` style message format"]
#[doc = " @return Not zero error code in the case of error."]
#[doc = ""]
#[doc = " @see iwlog_set_logfn(IWLOG_FN)"]
pub type IWLOG_FN = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut FILE,
        locale: locale_t,
        lvl: iwlog_lvl,
        ecode: iwrc,
        errno_code: ::std::os::raw::c_int,
        werror_code: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        ts: u64,
        opts: *mut ::std::os::raw::c_void,
        fmt: *const ::std::os::raw::c_char,
        argp: *mut __va_list_tag,
    ) -> iwrc,
>;
#[doc = " @brief Return the locale aware error code explanation message."]
#[doc = ""]
#[doc = " @param locale Locale used. Can be `NULL`"]
#[doc = " @param ecode Error code"]
#[doc = " @return Message string describes a given error code or `NULL` if"]
#[doc = "         no message found."]
pub type IWLOG_ECODE_FN = ::std::option::Option<
    unsafe extern "C" fn(locale: locale_t, ecode: u32) -> *const ::std::os::raw::c_char,
>;
extern "C" {
    #[doc = " @brief Attach the specified @a errno_code code into @a rc code"]
    #[doc = " @param rc IOWOW error code"]
    #[doc = " @param errno_code Error code will be embedded into."]
    #[doc = " @return Updated rc code"]
    pub fn iwrc_set_errno(rc: iwrc, errno_code: ::std::os::raw::c_int) -> iwrc;
}
extern "C" {
    #[doc = " @brief Strip the attached `errno` code from the specified @a rc and"]
    #[doc = " return errno code."]
    #[doc = ""]
    #[doc = " @param rc `errno` code or `0`"]
    pub fn iwrc_strip_errno(rc: *mut iwrc) -> u32;
}
extern "C" {
    #[doc = " @brief Remove embedded @a errno code from the passed @a rc"]
    #[doc = " @param [in,out] rc"]
    pub fn iwrc_strip_code(rc: *mut iwrc);
}
extern "C" {
    #[doc = " @brief Sets current logging function."]
    #[doc = " @warning Not thread safe."]
    #[doc = ""]
    #[doc = " @param fp Logging function pointer."]
    #[doc = " @return Not zero if error occured."]
    pub fn iwlog_set_logfn(fp: IWLOG_FN, opts: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Get a default logging function."]
    #[doc = ""]
    pub fn iwlog_get_logfn() -> IWLOG_FN;
}
extern "C" {
    #[doc = " @brief Returns string representation of a given error code."]
    #[doc = " @param ecode Error code"]
    #[doc = " @return"]
    pub fn iwlog_ecode_explained(ecode: iwrc) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Register error code explanation function."]
    #[doc = " @note Up to `128` @a fp functions can be registered."]
    #[doc = " @param fp"]
    #[doc = " @return `0` on success or error code."]
    pub fn iwlog_register_ecodefn(fp: IWLOG_ECODE_FN) -> iwrc;
}
extern "C" {
    #[doc = " @brief Logs a message."]
    #[doc = " @param lvl       Logging level."]
    #[doc = " @param ecode     Error code or zero."]
    #[doc = " @param file      Module file, can be `NULL`"]
    #[doc = " @param line      Line in module."]
    #[doc = " @param fmt       Printf like message format."]
    #[doc = " @return"]
    pub fn iwlog(
        lvl: iwlog_lvl,
        ecode: iwrc,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> iwrc;
}
extern "C" {
    pub fn iwlog2(
        lvl: iwlog_lvl,
        ecode: iwrc,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn iwlog_va(
        out: *mut FILE,
        lvl: iwlog_lvl,
        ecode: iwrc,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        argp: *mut __va_list_tag,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Initiate this submodule."]
    #[doc = " @return `0` on success or error code."]
    pub fn iwlog_init() -> iwrc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}iwcpuflags"]
    pub static mut iwcpuflags: ::std::os::raw::c_uint;
}
pub const iwp_ecode__IWP_ERROR_FS_START: iwp_ecode = 72000;
pub const iwp_ecode__IWP_ERROR_FS_END: iwp_ecode = 72001;
#[doc = " @enum iwp_ecode"]
#[doc = " @brief Error codes."]
pub type iwp_ecode = u32;
#[doc = " File locking mode acquired by process opened this file."]
pub type iwp_lockmode = u8;
#[doc = "< Ordinary file."]
pub const iwp_file_type_IWP_TYPE_FILE: iwp_file_type = 0;
#[doc = "< Directory."]
pub const iwp_file_type_IWP_TYPE_DIR: iwp_file_type = 1;
#[doc = "< Symlink."]
pub const iwp_file_type_IWP_LINK: iwp_file_type = 2;
#[doc = "< Other file types, eg soc, block, pipe.."]
pub const iwp_file_type_IWP_OTHER: iwp_file_type = 3;
#[doc = " @enum iwp_file_type"]
#[doc = " @brief File type."]
pub type iwp_file_type = u32;
pub const iwp_seek_origin_IWP_SEEK_SET: iwp_seek_origin = 1;
pub const iwp_seek_origin_IWP_SEEK_CUR: iwp_seek_origin = 2;
pub const iwp_seek_origin_IWP_SEEK_END: iwp_seek_origin = 3;
pub type iwp_seek_origin = u32;
extern "C" {
    #[doc = " Portable version of `int clock_gettime(clockid_t clk_id, struct timespec *tp)`"]
    pub fn iwp_clock_get_time(clock_id: ::std::os::raw::c_int, t: *mut timespec) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get current time in milliseconds."]
    #[doc = ""]
    #[doc = " @param [out] time Time returned"]
    #[doc = " @return `0` for success, or error code"]
    pub fn iwp_current_time_ms(time: *mut u64, monotonic: bool) -> iwrc;
}
#[doc = " @brief File info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWP_FILE_STAT {
    #[doc = "< File size."]
    pub size: u64,
    #[doc = "< Time of last access."]
    pub atime: u64,
    #[doc = "< Time of last status change."]
    pub ctime: u64,
    #[doc = "< Time of last modification."]
    pub mtime: u64,
    #[doc = "< File type."]
    pub ftype: iwp_file_type,
}
#[test]
fn bindgen_test_layout_IWP_FILE_STAT() {
    assert_eq!(
        ::std::mem::size_of::<IWP_FILE_STAT>(),
        40usize,
        concat!("Size of: ", stringify!(IWP_FILE_STAT))
    );
    assert_eq!(
        ::std::mem::align_of::<IWP_FILE_STAT>(),
        8usize,
        concat!("Alignment of ", stringify!(IWP_FILE_STAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWP_FILE_STAT>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWP_FILE_STAT),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWP_FILE_STAT>())).atime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWP_FILE_STAT),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWP_FILE_STAT>())).ctime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWP_FILE_STAT),
            "::",
            stringify!(ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWP_FILE_STAT>())).mtime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IWP_FILE_STAT),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWP_FILE_STAT>())).ftype as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IWP_FILE_STAT),
            "::",
            stringify!(ftype)
        )
    );
}
extern "C" {
    #[doc = " @brief Stat the file specified by @a path."]
    #[doc = ""]
    #[doc = " @param path File path"]
    #[doc = " @param [out] stat File stat info placeholder."]
    #[doc = " @return `0` on sucess or error code."]
    pub fn iwp_fstat(path: *const ::std::os::raw::c_char, stat: *mut IWP_FILE_STAT) -> iwrc;
}
extern "C" {
    pub fn iwp_fstath(fh: HANDLE, stat: *mut IWP_FILE_STAT) -> iwrc;
}
extern "C" {
    #[doc = " @brief Lock the file."]
    #[doc = ""]
    #[doc = " @param fh File handle."]
    #[doc = " @param lmode Lock mode specified."]
    #[doc = " @return `0` on sucess or error code."]
    pub fn iwp_flock(fh: HANDLE, lmode: iwp_lockmode) -> iwrc;
}
extern "C" {
    #[doc = " @brief Unlock the file specified by @a fh"]
    #[doc = " @param fh File handle"]
    #[doc = " @return `0` on sucess or error code."]
    pub fn iwp_unlock(fh: HANDLE) -> iwrc;
}
extern "C" {
    #[doc = " @brief Close the specified file handle (File descriptor)."]
    #[doc = " @param fh File handle."]
    pub fn iwp_closefh(fh: HANDLE) -> iwrc;
}
extern "C" {
    #[doc = " @brief Read @a siz bytes from file @a fh"]
    #[doc = "        into @a buf at the specified offset @a off."]
    #[doc = ""]
    #[doc = " @param fh        File handle."]
    #[doc = " @param off       Offset from start of the file."]
    #[doc = " @param [out] buf       Buffer into which bytes will read."]
    #[doc = " @param siz       Number of bytes to read."]
    #[doc = " @param [out] sp  Number of bytes read actually"]
    #[doc = " @return `0` on sucess or error code."]
    pub fn iwp_pread(
        fh: HANDLE,
        off: off_t,
        buf: *mut ::std::os::raw::c_void,
        siz: usize,
        sp: *mut usize,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Write @a siz bytes into file @a fh"]
    #[doc = "        at the specified offset @a off"]
    #[doc = "        from buffer @a buf."]
    #[doc = ""]
    #[doc = " @param fh    File handle."]
    #[doc = " @param off   Offset from start of the file."]
    #[doc = " @param buf   Data buffer to write."]
    #[doc = " @param siz   Number of bytes to write."]
    #[doc = " @param [out] sp   Number of bytes written."]
    #[doc = " @return `0` on sucess or error code."]
    pub fn iwp_pwrite(
        fh: HANDLE,
        off: off_t,
        buf: *const ::std::os::raw::c_void,
        siz: usize,
        sp: *mut usize,
    ) -> iwrc;
}
extern "C" {
    pub fn iwp_write(fh: HANDLE, buf: *const ::std::os::raw::c_void, count: usize) -> iwrc;
}
extern "C" {
    pub fn iwp_read(
        fh: HANDLE,
        buf: *mut ::std::os::raw::c_void,
        count: usize,
        sp: *mut usize,
    ) -> iwrc;
}
extern "C" {
    pub fn iwp_lseek(fh: HANDLE, offset: off_t, origin: iwp_seek_origin, pos: *mut off_t) -> iwrc;
}
extern "C" {
    #[doc = " @brief Copy data within a file"]
    #[doc = " @param off Data offset"]
    #[doc = " @param siz Data size"]
    #[doc = " @param noff New data offset"]
    pub fn iwp_copy_bytes(fh: HANDLE, off: off_t, siz: usize, noff: off_t) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get system page size."]
    pub fn iwp_page_size() -> usize;
}
extern "C" {
    #[doc = " @brief Minimal address space aligment for memory mapping."]
    pub fn iwp_alloc_unit() -> usize;
}
extern "C" {
    #[doc = " @brief Truncate a file specified by @a fh to a size of @a len bytes"]
    #[doc = " @param fh File handle"]
    #[doc = " @param len File size"]
    #[doc = " @return `0` on sucess or error code."]
    pub fn iwp_ftruncate(fh: HANDLE, len: off_t) -> iwrc;
}
extern "C" {
    #[doc = " @brief Allocate extra space for a file."]
    #[doc = " @param fh File handle"]
    #[doc = " @param len New file size"]
    #[doc = " @return `0` on sucess or error code."]
    pub fn iwp_fallocate(fh: HANDLE, len: off_t) -> iwrc;
}
extern "C" {
    #[doc = " @brief Pause execution of current thread"]
    #[doc = "        to the specified @a ms time in milliseconds."]
    #[doc = " @param ms Thread pause time"]
    pub fn iwp_sleep(ms: u64) -> iwrc;
}
extern "C" {
    #[doc = " @brief Recursive directory removal specified by @a path."]
    #[doc = " @param path Directory path"]
    pub fn iwp_removedir(path: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    #[doc = " @brief Make directory specified by `path`"]
    #[doc = " as well as all parent directories."]
    #[doc = ""]
    #[doc = " @param path Path to directory."]
    pub fn iwp_mkdirs(path: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get executable path for the current process."]
    #[doc = " It will be writein into @a opath"]
    #[doc = " @param opath Allocated buffer at least `PATH_MAX` length"]
    pub fn iwp_exec_path(opath: *mut ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    #[doc = " @brief Return number of CPU cores."]
    pub fn iwp_num_cpu_cores() -> u16;
}
extern "C" {
    #[doc = " @brief Init iwp module."]
    #[doc = " @return `0` on success or error code."]
    pub fn iwp_init() -> iwrc;
}
extern "C" {
    pub fn iwp_fsync(fh: HANDLE) -> iwrc;
}
extern "C" {
    pub fn iwp_fdatasync(fh: HANDLE) -> iwrc;
}
extern "C" {
    #[doc = " Write system tmp directory path into provided `out` buffer."]
    #[doc = " Write at most `len` bytes not including terminating `NULL` char."]
    #[doc = " @return Number of bytes writen. Zero on error."]
    pub fn iwp_tmpdir(out: *mut ::std::os::raw::c_char, len: usize) -> usize;
}
extern "C" {
    #[doc = " Allocates unique temp file path. Caller should use `free()`"]
    #[doc = " to release path buffer."]
    #[doc = " @return Zero on error."]
    pub fn iwp_allocate_tmpfile_path(
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set name of the current thread. On some platforms"]
    #[doc = " thread name canot be longer than 16 bytes including zero terminator."]
    pub fn iwp_set_current_thread_name(name: *const ::std::os::raw::c_char);
}
#[doc = " @brief File data events listener."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWDLSNR {
    #[doc = " @brief Before file open event."]
    #[doc = ""]
    #[doc = " @param path File path"]
    #[doc = " @param mode File open mode same as in open(2)"]
    pub onopen: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut IWDLSNR,
            path: *const ::std::os::raw::c_char,
            mode: ::std::os::raw::c_int,
        ) -> iwrc,
    >,
    #[doc = " @brief Before file been closed."]
    pub onclosing: ::std::option::Option<unsafe extern "C" fn(self_: *mut IWDLSNR) -> iwrc>,
    #[doc = " @brief Write @a val value starting at @a off @a len bytes"]
    pub onset: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut IWDLSNR,
            off: off_t,
            val: u8,
            len: off_t,
            flags: ::std::os::raw::c_int,
        ) -> iwrc,
    >,
    #[doc = " @brief Copy @a len bytes from @a off offset to @a noff offset"]
    pub oncopy: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut IWDLSNR,
            off: off_t,
            len: off_t,
            noff: off_t,
            flags: ::std::os::raw::c_int,
        ) -> iwrc,
    >,
    #[doc = " @brief Write @buf of @a len bytes at @a off"]
    pub onwrite: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut IWDLSNR,
            off: off_t,
            buf: *const ::std::os::raw::c_void,
            len: off_t,
            flags: ::std::os::raw::c_int,
        ) -> iwrc,
    >,
    #[doc = " @brief File need to be resized."]
    #[doc = ""]
    #[doc = " @param osize Old file size"]
    #[doc = " @param nsize New file size"]
    #[doc = " @param [out] handled File resizing handled by llistener."]
    pub onresize: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut IWDLSNR,
            osize: off_t,
            nsize: off_t,
            flags: ::std::os::raw::c_int,
            handled: *mut bool,
        ) -> iwrc,
    >,
    #[doc = " @brief File sync successful"]
    pub onsynced: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut IWDLSNR, flags: ::std::os::raw::c_int) -> iwrc,
    >,
}
#[test]
fn bindgen_test_layout_IWDLSNR() {
    assert_eq!(
        ::std::mem::size_of::<IWDLSNR>(),
        56usize,
        concat!("Size of: ", stringify!(IWDLSNR))
    );
    assert_eq!(
        ::std::mem::align_of::<IWDLSNR>(),
        8usize,
        concat!("Alignment of ", stringify!(IWDLSNR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWDLSNR>())).onopen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDLSNR),
            "::",
            stringify!(onopen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWDLSNR>())).onclosing as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDLSNR),
            "::",
            stringify!(onclosing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWDLSNR>())).onset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDLSNR),
            "::",
            stringify!(onset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWDLSNR>())).oncopy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDLSNR),
            "::",
            stringify!(oncopy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWDLSNR>())).onwrite as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDLSNR),
            "::",
            stringify!(onwrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWDLSNR>())).onresize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDLSNR),
            "::",
            stringify!(onresize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWDLSNR>())).onsynced as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDLSNR),
            "::",
            stringify!(onsynced)
        )
    );
}
#[doc = " File open mode"]
pub type iwfs_omode = u8;
#[doc = "  Status of an open file operation"]
pub type iwfs_openstatus = u8;
#[doc = " Sync file data options"]
pub type iwfs_sync_flags = u8;
#[doc = " @brief `IWFS_FILE` file options."]
#[doc = " @see iwrc iwfs_file_open(IWFS_FILE *f, const IWFS_FILE_OPTS *opts)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_FILE_OPTS {
    #[doc = "< Required file path."]
    pub path: *const ::std::os::raw::c_char,
    #[doc = "< File open mode."]
    pub omode: iwfs_omode,
    #[doc = "< File locking mode. */"]
    #[doc = "`int open(const char *pathname, int flags, mode_t mode)`"]
    pub lock_mode: iwp_lockmode,
    pub filemode: ::std::os::raw::c_int,
    #[doc = "< Optional data listener"]
    pub dlsnr: *mut IWDLSNR,
}
#[test]
fn bindgen_test_layout_IWFS_FILE_OPTS() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_FILE_OPTS>(),
        24usize,
        concat!("Size of: ", stringify!(IWFS_FILE_OPTS))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_FILE_OPTS>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_FILE_OPTS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE_OPTS>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE_OPTS),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE_OPTS>())).omode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE_OPTS),
            "::",
            stringify!(omode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE_OPTS>())).lock_mode as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE_OPTS),
            "::",
            stringify!(lock_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE_OPTS>())).filemode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE_OPTS),
            "::",
            stringify!(filemode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE_OPTS>())).dlsnr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE_OPTS),
            "::",
            stringify!(dlsnr)
        )
    );
}
#[doc = " @brief `IWFS_FILE` file state info."]
#[doc = " @see IWFS_FILE::state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_FILE_STATE {
    #[doc = "< `1` if file in open state"]
    pub is_open: ::std::os::raw::c_int,
    #[doc = "< File open status."]
    pub ostatus: iwfs_openstatus,
    #[doc = "< File open options."]
    pub opts: IWFS_FILE_OPTS,
    #[doc = "< File handle"]
    pub fh: HANDLE,
}
#[test]
fn bindgen_test_layout_IWFS_FILE_STATE() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_FILE_STATE>(),
        40usize,
        concat!("Size of: ", stringify!(IWFS_FILE_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_FILE_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_FILE_STATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE_STATE>())).is_open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE_STATE),
            "::",
            stringify!(is_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE_STATE>())).ostatus as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE_STATE),
            "::",
            stringify!(ostatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE_STATE>())).opts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE_STATE),
            "::",
            stringify!(opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE_STATE>())).fh as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE_STATE),
            "::",
            stringify!(fh)
        )
    );
}
#[doc = " @struct IWFS_FILE"]
#[doc = " @brief Simple file implementation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_FILE {
    #[doc = "< Implementation specific data"]
    pub impl_: *mut ::std::os::raw::c_void,
    #[doc = " @brief Write @a buf bytes into the file"]
    #[doc = ""]
    #[doc = " @param f `struct IWFS_FILE` pointer"]
    #[doc = " @param off Offset from start of the file where bytes will write."]
    #[doc = " @param buf Buffer to write."]
    #[doc = " @param siz Number of bytes to write."]
    #[doc = " @param [out] sp Number of bytes actually written"]
    #[doc = " @return `0` on success or error code."]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FILE,
            off: off_t,
            buf: *const ::std::os::raw::c_void,
            siz: usize,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = " @brief Read @a siz bytes into @a buf at the specified offset @a off"]
    #[doc = ""]
    #[doc = " @param f `struct IWFS_FILE` pointer."]
    #[doc = " @param off Offset from start of the file."]
    #[doc = " @param buf Buffer to read into."]
    #[doc = " @param siz Number of bytes to read."]
    #[doc = " @param [out] sp Number of bytes actually read."]
    #[doc = " @return `0` on success or error code."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FILE,
            off: off_t,
            buf: *mut ::std::os::raw::c_void,
            siz: usize,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = " @brief Closes this file."]
    #[doc = " @return `0` on success or error code."]
    pub close: ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_FILE) -> iwrc>,
    #[doc = " @brief Sync file data with fs."]
    #[doc = " @param f `struct IWFS_FILE` pointer."]
    #[doc = " @param opts File sync options."]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FILE, flags: iwfs_sync_flags) -> iwrc,
    >,
    #[doc = " @brief Return current file state."]
    #[doc = " @param f `struct IWFS_FILE` pointer."]
    #[doc = " @param [out] state File state placeholder."]
    #[doc = " @return `0` on success or error code."]
    #[doc = ""]
    #[doc = " @see struct IWFS_FILE_STATE"]
    pub state: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FILE, state: *mut IWFS_FILE_STATE) -> iwrc,
    >,
    #[doc = " @brief Copy data within a file"]
    #[doc = " @param f `struct IWFS_FILE` pointer."]
    #[doc = " @param off Data offset"]
    #[doc = " @param siz Data size"]
    #[doc = " @param noff New data offset"]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FILE, off: off_t, siz: usize, noff: off_t) -> iwrc,
    >,
}
#[test]
fn bindgen_test_layout_IWFS_FILE() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_FILE>(),
        56usize,
        concat!("Size of: ", stringify!(IWFS_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE>())).write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE>())).read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE>())).close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE>())).sync as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FILE>())).copy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FILE),
            "::",
            stringify!(copy)
        )
    );
}
extern "C" {
    #[doc = " @brief Open file and initialize a given @a f structure."]
    #[doc = ""]
    #[doc = " <strong>File open options:</strong>"]
    #[doc = " @code {.c}"]
    #[doc = "   opts = {"]
    #[doc = "      .path = \"file path\",  //File path. This options value is requied."]
    #[doc = "      .omode =  ...,        //File open mode."]
    #[doc = "                            //    Default: `IWFS_DEFAULT_OMODE`"]
    #[doc = "      .lock_mode = ...,     //File locking mode acquired by process opened this file."]
    #[doc = "                            //    Default: `IWP_NOLOCK`"]
    #[doc = "      .filemode = ..        //Specifies the permissions to use in case a new file is created."]
    #[doc = "                            //    Default: `00644`"]
    #[doc = "   }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param f `struct IWFS_FILE` pointer."]
    #[doc = " @param opts [in] File open options"]
    #[doc = " @return `0` on success or error code."]
    #[doc = " @relatesalso IWFS_FILE"]
    pub fn iwfs_file_open(f: *mut IWFS_FILE, opts: *const IWFS_FILE_OPTS) -> iwrc;
}
extern "C" {
    #[doc = " @brief Init `iwfile` submodule."]
    pub fn iwfs_file_init() -> iwrc;
}
pub const iwfs_ext_ecode__IWFS_EXT_ERROR_START: iwfs_ext_ecode = 73000;
#[doc = "< Region is mmaped already, mmaping overlaps"]
pub const iwfs_ext_ecode_IWFS_ERROR_MMAP_OVERLAP: iwfs_ext_ecode = 73001;
#[doc = "< Region is not mmaped"]
pub const iwfs_ext_ecode_IWFS_ERROR_NOT_MMAPED: iwfs_ext_ecode = 73002;
#[doc = "< Invalid result of resize policy function."]
pub const iwfs_ext_ecode_IWFS_ERROR_RESIZE_POLICY_FAIL: iwfs_ext_ecode = 73003;
#[doc = "< Maximum file offset reached."]
pub const iwfs_ext_ecode_IWFS_ERROR_MAXOFF: iwfs_ext_ecode = 73004;
pub const iwfs_ext_ecode__IWFS_EXT_ERROR_END: iwfs_ext_ecode = 73005;
#[doc = " @enum iwfs_ext_ecode"]
#[doc = " @brief Error codes specific to this module."]
pub type iwfs_ext_ecode = u32;
pub type iwfs_ext_mmap_opts_t = u8;
#[doc = " @brief File resize policy function type."]
#[doc = ""]
#[doc = " This function called in the following cases:"]
#[doc = "  - When a file needs to be resized. Returned new file size cannot"]
#[doc = "    be lesser than requested @a nsize and must be `page aligned`."]
#[doc = "  - When a file is closed. In this case the first argument @a nsize"]
#[doc = "    will be set to `-1` and function should return `0`."]
#[doc = "    This call can be used in order to release resources allocated for @a ctx"]
#[doc = "    private data used in function."]
#[doc = ""]
#[doc = " @param nsize Desired file size."]
#[doc = " @param csize Current file size."]
#[doc = " @param f File reference."]
#[doc = " @param ctx Function context data pointer. A function is allowed to initialize"]
#[doc = " this pointer by own private data stucture."]
#[doc = ""]
#[doc = " @return Computed new file size."]
pub type IW_EXT_RSPOLICY = ::std::option::Option<
    unsafe extern "C" fn(
        nsize: off_t,
        csize: off_t,
        f: *mut IWFS_EXT,
        ctx: *mut *mut ::std::os::raw::c_void,
    ) -> off_t,
>;
extern "C" {
    #[doc = " @brief Fibonacci resize file policy."]
    #[doc = ""]
    #[doc = " New `file_size(n+1) = MAX(file_size(n) + file_size(n-1), nsize)`"]
    pub fn iw_exfile_szpolicy_fibo(
        nsize: off_t,
        csize: off_t,
        f: *mut IWFS_EXT,
        ctx: *mut *mut ::std::os::raw::c_void,
    ) -> off_t;
}
extern "C" {
    #[doc = " @brief Rational number `IW_RNUM` file size multiplication policy."]
    #[doc = ""]
    #[doc = " New `file_size = MAX(file_size * (N/D), nsize)`"]
    pub fn iw_exfile_szpolicy_mul(
        nsize: off_t,
        csize: off_t,
        f: *mut IWFS_EXT,
        ctx: *mut *mut ::std::os::raw::c_void,
    ) -> off_t;
}
#[doc = " @brief `IWFS_EXT` file options."]
#[doc = " @see iwrc iwfs_exfile_open(IWFS_EXT *f, const IWFS_EXT_OPTS *opts)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_EXT_OPTS {
    #[doc = "< Underlying file options"]
    pub file: IWFS_FILE_OPTS,
    #[doc = "< Initial file size"]
    pub initial_size: off_t,
    #[doc = "< If `true` file operations will be guarded by rw lock. Default: `false`"]
    pub use_locks: bool,
    #[doc = "< File resize policy function ptr. Default:"]
    #[doc = "`exact size policy`"]
    pub rspolicy: IW_EXT_RSPOLICY,
    #[doc = "< Custom opaque data for policy functions."]
    #[doc = "Default: `0`"]
    pub rspolicy_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Maximum allowed file offset. Unlimited if zero."]
    #[doc = "If maximum offset is reached `IWFS_ERROR_MAXOFF` will be reported."]
    pub maxoff: u64,
}
#[test]
fn bindgen_test_layout_IWFS_EXT_OPTS() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_EXT_OPTS>(),
        64usize,
        concat!("Size of: ", stringify!(IWFS_EXT_OPTS))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_EXT_OPTS>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_EXT_OPTS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT_OPTS>())).file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT_OPTS),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT_OPTS>())).initial_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT_OPTS),
            "::",
            stringify!(initial_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT_OPTS>())).use_locks as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT_OPTS),
            "::",
            stringify!(use_locks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT_OPTS>())).rspolicy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT_OPTS),
            "::",
            stringify!(rspolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT_OPTS>())).rspolicy_ctx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT_OPTS),
            "::",
            stringify!(rspolicy_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT_OPTS>())).maxoff as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT_OPTS),
            "::",
            stringify!(maxoff)
        )
    );
}
#[doc = " @struct IWFS_EXT_STATE"]
#[doc = " @brief `IWFS_EXT` file state info."]
#[doc = " @see IWFS_EXT::state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_EXT_STATE {
    #[doc = "< Simple file state"]
    pub file: IWFS_FILE_STATE,
    #[doc = "< Current file size"]
    pub fsize: off_t,
}
#[test]
fn bindgen_test_layout_IWFS_EXT_STATE() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_EXT_STATE>(),
        48usize,
        concat!("Size of: ", stringify!(IWFS_EXT_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_EXT_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_EXT_STATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT_STATE>())).file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT_STATE),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT_STATE>())).fsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT_STATE),
            "::",
            stringify!(fsize)
        )
    );
}
#[doc = " @brief Auto-expandable file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_EXT {
    pub impl_: *mut IWFS_EXT_IMPL,
    #[doc = " @brief Ensures that a file's physical address space contains a given offset"]
    #[doc = " @a off"]
    #[doc = ""]
    #[doc = " Various algorithms can be used for new space allocation,"]
    #[doc = " see the features section for further explanation."]
    #[doc = ""]
    #[doc = " @param f `IWFS_EXT`"]
    #[doc = " @param off File offset what have to be within physically allocated file"]
    #[doc = "            address space."]
    #[doc = " @return `0` on success or error code."]
    #[doc = ""]
    #[doc = " @see off_t iw_exfile_szpolicy_fibo(off_t nsize, off_t csize, struct"]
    #[doc = " IWFS_EXT *f, void **ctx)"]
    #[doc = " @see off_t iw_exfile_szpolicy_mul(off_t nsize, off_t csize, struct IWFS_EXT"]
    #[doc = " *f, void **ctx)"]
    pub ensure_size:
        ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_EXT, off: off_t) -> iwrc>,
    #[doc = " @brief Set the end of this file to the specified offset @a off exactly."]
    pub truncate: ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_EXT, off: off_t) -> iwrc>,
    pub truncate_unsafe:
        ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_EXT, off: off_t) -> iwrc>,
    #[doc = " @brief Register an address space specified by @a off and @a len as memory"]
    #[doc = " mmaped region"]
    #[doc = " within this file."]
    #[doc = ""]
    #[doc = " It is not required for this region be physically represented in the file's"]
    #[doc = " address space."]
    #[doc = " As soon as this region will be used for reading/writing it will be mmaped"]
    #[doc = " and direct mmaped memory access will be used for IO in this area."]
    #[doc = ""]
    #[doc = " For example:"]
    #[doc = " @code {.c}"]
    #[doc = "     f.add_mmap(&f, 10, 20);"]
    #[doc = "     f.read(&f, 5, buf, 10, sp); // read [5-15) bytes"]
    #[doc = "     // [5-10) bytes will be read using system `pread`"]
    #[doc = "     // [10-15) bytes will be retrieved by direct `memcpy` from mmapped"]
    #[doc = " region"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " Pointer to this region can be retrieved by  `IWFS_EXT::acquire_mmap`"]
    #[doc = ""]
    #[doc = " @param f `IWFS_EXT`"]
    #[doc = " @param off Offset of mmaped region"]
    #[doc = " @param len Length of mmaped region"]
    #[doc = " @return `0` on success or error code."]
    pub add_mmap: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_EXT,
            off: off_t,
            len: usize,
            opts: iwfs_ext_mmap_opts_t,
        ) -> iwrc,
    >,
    pub add_mmap_unsafe: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_EXT,
            off: off_t,
            len: usize,
            opts: iwfs_ext_mmap_opts_t,
        ) -> iwrc,
    >,
    #[doc = " @brief Retrieve mmaped region by its offset @a off and keep file as read locked."]
    #[doc = ""]
    #[doc = " If region was not mmaped previously with IWFS_EXT::add_mmap"]
    #[doc = " the `IWFS_ERROR_NOT_MMAPED` error code will be returned."]
    #[doc = ""]
    #[doc = " WARNING: Internal read lock will be acquired and"]
    #[doc = "          must be released by subsequent `release_mmap()` call"]
    #[doc = "          after all activity with mmaped region has finished."]
    #[doc = ""]
    #[doc = " @param f `IWFS_EXT`"]
    #[doc = " @param off Region start offset"]
    #[doc = " @param [out] mm Pointer assigned to start of mmaped region of `NULL` if"]
    #[doc = "                 error occurred."]
    #[doc = " @param [out] sp Length of region"]
    #[doc = " @return `0` on success or error code."]
    pub acquire_mmap: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_EXT,
            off: off_t,
            mm: *mut *mut u8,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = " @brief Retrieve mmaped region by its offset @a off"]
    pub probe_mmap: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_EXT,
            off: off_t,
            mm: *mut *mut u8,
            sp: *mut usize,
        ) -> iwrc,
    >,
    pub probe_mmap_unsafe: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_EXT,
            off: off_t,
            mm: *mut *mut u8,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = " @brief Release the lock acquired by successfull call of `acquire_mmap()`"]
    pub release_mmap: ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_EXT) -> iwrc>,
    #[doc = " @brief Unmap mmaped region identified by @a off"]
    #[doc = ""]
    #[doc = " The `IWFS_ERROR_NOT_MMAPED` will returned"]
    #[doc = " if region was not previously mapped with IWFS_EXT::add_mmap"]
    #[doc = ""]
    #[doc = " @param f `IWFS_EXT`"]
    #[doc = " @param off Region start offset"]
    #[doc = " @return `0` on success or error code."]
    pub remove_mmap:
        ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_EXT, off: off_t) -> iwrc>,
    pub remove_mmap_unsafe:
        ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_EXT, off: off_t) -> iwrc>,
    #[doc = " @brief Synchronize a file with a mmaped region identified by @a off offset."]
    #[doc = ""]
    #[doc = " The `IWFS_ERROR_NOT_MMAPED` will returned"]
    #[doc = " if region was not previously mapped with IWFS_EXT::add_mmap"]
    #[doc = ""]
    #[doc = " @param f `IWFS_EXT`"]
    #[doc = " @param off Region start offset"]
    #[doc = " @param flags Sync flags."]
    #[doc = " @return `0` on success or error code."]
    pub sync_mmap: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_EXT, off: off_t, flags: iwfs_sync_flags) -> iwrc,
    >,
    pub sync_mmap_unsafe: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_EXT, off: off_t, flags: iwfs_sync_flags) -> iwrc,
    >,
    #[doc = " @brief Remap all mmaped regions."]
    #[doc = ""]
    #[doc = " @param f `IWFS_EXT`"]
    pub remap_all: ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_EXT) -> iwrc>,
    #[doc = "  @see IWFS_FILE::write"]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_EXT,
            off: off_t,
            buf: *const ::std::os::raw::c_void,
            siz: usize,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = "  @see IWFS_FILE::read"]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_EXT,
            off: off_t,
            buf: *mut ::std::os::raw::c_void,
            siz: usize,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = " @see IWFS_FILE::close"]
    pub close: ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_EXT) -> iwrc>,
    #[doc = "  @see IWFS_FILE::sync"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_EXT, flags: iwfs_sync_flags) -> iwrc,
    >,
    #[doc = "  @see IWFS_FILE::state"]
    pub state: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_EXT, state: *mut IWFS_EXT_STATE) -> iwrc,
    >,
    #[doc = "  @see IWFS_FILE::copy"]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_EXT, off: off_t, siz: usize, noff: off_t) -> iwrc,
    >,
}
#[test]
fn bindgen_test_layout_IWFS_EXT() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_EXT>(),
        168usize,
        concat!("Size of: ", stringify!(IWFS_EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_EXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).ensure_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(ensure_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).truncate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(truncate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).truncate_unsafe as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(truncate_unsafe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).add_mmap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(add_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).add_mmap_unsafe as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(add_mmap_unsafe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).acquire_mmap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(acquire_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).probe_mmap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(probe_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).probe_mmap_unsafe as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(probe_mmap_unsafe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).release_mmap as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(release_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).remove_mmap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(remove_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).remove_mmap_unsafe as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(remove_mmap_unsafe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).sync_mmap as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(sync_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).sync_mmap_unsafe as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(sync_mmap_unsafe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).remap_all as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(remap_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).write as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).read as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).close as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).sync as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).state as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_EXT>())).copy as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_EXT),
            "::",
            stringify!(copy)
        )
    );
}
extern "C" {
    #[doc = " @brief Open exfile."]
    #[doc = ""]
    #[doc = " <strong>Example:</strong>"]
    #[doc = ""]
    #[doc = " Open a file for multithreaded env with fibonacci file resize policy and"]
    #[doc = " initial size to 4K"]
    #[doc = ""]
    #[doc = " @code {.c}"]
    #[doc = "  IWFS_EXT_OPTS opts = {"]
    #[doc = "      .file = {"]
    #[doc = "          .path       = \"myfile.dat\","]
    #[doc = "          .omode      = IWFS_OWRITE | IWFS_OCREATE,"]
    #[doc = "          .lock_mode  = IWP_WLOCK"]
    #[doc = "      },"]
    #[doc = "      .initial_size   = 4096,"]
    #[doc = "      .use_locks      = true,"]
    #[doc = "      .rspolicy       = iw_exfile_szpolicy_fibo"]
    #[doc = "  };"]
    #[doc = "  IWFS_EXT f;"]
    #[doc = "  iwrc rc = iwfs_exfile_open(&f, &opts);"]
    #[doc = ""]
    #[doc = "  rc = f.write(&f, ...);"]
    #[doc = "  ..."]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param f Exfile handle. Simple memory placeholder."]
    #[doc = " @param opts File open options. Initialized file options."]
    #[doc = " @return Error code of `0` on success."]
    #[doc = " @relatesalso IWFS_EXT"]
    pub fn iwfs_exfile_open(f: *mut IWFS_EXT, opts: *const IWFS_EXT_OPTS) -> iwrc;
}
extern "C" {
    #[doc = " @brief Init `iwexfile` submodule."]
    pub fn iwfs_exfile_init() -> iwrc;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = 0;
pub const FP_INFINITE: _bindgen_ty_1 = 1;
pub const FP_ZERO: _bindgen_ty_1 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = u32;
#[doc = " Free space allocation flags"]
#[doc = "  @see IWFS_FSM::allocate"]
pub type iwfs_fsm_aflags = u8;
#[doc = " File cleanup flags used in `IWFS_FSM::clear`"]
pub type iwfs_fsm_clrfalgs = u8;
#[doc = " `IWFS_FSM` file open modes used in `IWFS_FSM_OPTS`"]
pub type iwfs_fsm_openflags = u8;
pub const iwfs_fsm_ecode__IWFS_FSM_ERROR_START: iwfs_fsm_ecode = 74000;
#[doc = "< No free space."]
pub const iwfs_fsm_ecode_IWFS_ERROR_NO_FREE_SPACE: iwfs_fsm_ecode = 74001;
#[doc = "< Invalid block size specified"]
pub const iwfs_fsm_ecode_IWFS_ERROR_INVALID_BLOCK_SIZE: iwfs_fsm_ecode = 74002;
pub const iwfs_fsm_ecode_IWFS_ERROR_RANGE_NOT_ALIGNED: iwfs_fsm_ecode = 74003;
#[doc = "< Free-space map segmentation error"]
pub const iwfs_fsm_ecode_IWFS_ERROR_FSM_SEGMENTATION: iwfs_fsm_ecode = 74004;
#[doc = "< Invalid file-metadata"]
pub const iwfs_fsm_ecode_IWFS_ERROR_INVALID_FILEMETA: iwfs_fsm_ecode = 74005;
pub const iwfs_fsm_ecode_IWFS_ERROR_PLATFORM_PAGE: iwfs_fsm_ecode = 74006;
#[doc = "< Failed to resize file"]
pub const iwfs_fsm_ecode_IWFS_ERROR_RESIZE_FAIL: iwfs_fsm_ecode = 74007;
pub const iwfs_fsm_ecode__IWFS_FSM_ERROR_END: iwfs_fsm_ecode = 74008;
#[doc = " @brief Error codes specific to `IWFS_FSM`."]
pub type iwfs_fsm_ecode = u32;
#[doc = " @brief `IWFS_FSM` file options."]
#[doc = " @see iwfs_fsmfile_open(IWFS_FSM *f, const IWFS_FSM_OPTS *opts)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_FSM_OPTS {
    pub exfile: IWFS_EXT_OPTS,
    #[doc = "< Initial size of free-space bitmap"]
    pub bmlen: usize,
    #[doc = "< Length of custom file header."]
    pub hdrlen: u32,
    #[doc = "< Operation mode flags"]
    pub oflags: iwfs_fsm_openflags,
    #[doc = "< Defaul mmap options used in `add_mmap`"]
    pub mmap_opts: iwfs_ext_mmap_opts_t,
    #[doc = "< Block size power for 2"]
    pub bpow: u8,
    #[doc = "< Mmap all file data"]
    pub mmap_all: bool,
}
#[test]
fn bindgen_test_layout_IWFS_FSM_OPTS() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_FSM_OPTS>(),
        80usize,
        concat!("Size of: ", stringify!(IWFS_FSM_OPTS))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_FSM_OPTS>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_FSM_OPTS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_OPTS>())).exfile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_OPTS),
            "::",
            stringify!(exfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_OPTS>())).bmlen as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_OPTS),
            "::",
            stringify!(bmlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_OPTS>())).hdrlen as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_OPTS),
            "::",
            stringify!(hdrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_OPTS>())).oflags as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_OPTS),
            "::",
            stringify!(oflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_OPTS>())).mmap_opts as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_OPTS),
            "::",
            stringify!(mmap_opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_OPTS>())).bpow as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_OPTS),
            "::",
            stringify!(bpow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_OPTS>())).mmap_all as *const _ as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_OPTS),
            "::",
            stringify!(mmap_all)
        )
    );
}
#[doc = " @brief `IWFS_FSM` file state container."]
#[doc = " @see IWFS_FSM::state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_FSM_STATE {
    #[doc = "< File pool state"]
    pub exfile: IWFS_EXT_STATE,
    #[doc = "< Size of data block in bytes."]
    pub block_size: usize,
    #[doc = "< Operation mode flags."]
    pub oflags: iwfs_fsm_openflags,
    #[doc = "< Length of custom file header length in bytes"]
    pub hdrlen: u32,
    #[doc = "< Number of available data blocks."]
    pub blocks_num: u64,
    #[doc = "< Number of free (deallocated) continuous data"]
    #[doc = "segments."]
    pub free_segments_num: u64,
    #[doc = "< Average allocation number of blocks"]
    pub avg_alloc_size: double_t,
    #[doc = "< Average allocation blocks dispersion"]
    pub alloc_dispersion: double_t,
}
#[test]
fn bindgen_test_layout_IWFS_FSM_STATE() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_FSM_STATE>(),
        96usize,
        concat!("Size of: ", stringify!(IWFS_FSM_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_FSM_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_FSM_STATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_STATE>())).exfile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_STATE),
            "::",
            stringify!(exfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_STATE>())).block_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_STATE),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_STATE>())).oflags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_STATE),
            "::",
            stringify!(oflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_STATE>())).hdrlen as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_STATE),
            "::",
            stringify!(hdrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_STATE>())).blocks_num as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_STATE),
            "::",
            stringify!(blocks_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IWFS_FSM_STATE>())).free_segments_num as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_STATE),
            "::",
            stringify!(free_segments_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_STATE>())).avg_alloc_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_STATE),
            "::",
            stringify!(avg_alloc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM_STATE>())).alloc_dispersion as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM_STATE),
            "::",
            stringify!(alloc_dispersion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_FSMDBG_STATE {
    pub state: IWFS_FSM_STATE,
    pub bmoff: u64,
    pub bmlen: u64,
    pub lfbklen: u64,
    pub lfbkoff: u64,
}
#[test]
fn bindgen_test_layout_IWFS_FSMDBG_STATE() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_FSMDBG_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(IWFS_FSMDBG_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_FSMDBG_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_FSMDBG_STATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSMDBG_STATE>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSMDBG_STATE),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSMDBG_STATE>())).bmoff as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSMDBG_STATE),
            "::",
            stringify!(bmoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSMDBG_STATE>())).bmlen as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSMDBG_STATE),
            "::",
            stringify!(bmlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSMDBG_STATE>())).lfbklen as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSMDBG_STATE),
            "::",
            stringify!(lfbklen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSMDBG_STATE>())).lfbkoff as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSMDBG_STATE),
            "::",
            stringify!(lfbkoff)
        )
    );
}
#[doc = " @brief Auto-expandable file with support of reader/writer address space"]
#[doc = " locking"]
#[doc = "        and free space blocks management using bitmaps."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_FSM {
    pub impl_: *mut IWFS_FSM_IMPL,
    #[doc = " @brief Allocate a continuous address space within a file"]
    #[doc = "        with length greater or equal to the desired @a len bytes."]
    #[doc = ""]
    #[doc = " `Offset` and  `length` allocated area will be block size aligned."]
    #[doc = ""]
    #[doc = " @param f `IWFS_FSM` file."]
    #[doc = " @param len Desired length of an allocated area in bytes."]
    #[doc = " @param [in,out] oaddr Placeholder for the address of an allocated area."]
    #[doc = "                       Value of @a oaddr passed to this function used as"]
    #[doc = " `hint` in order"]
    #[doc = "                       to allocate area located closely to the specified @a"]
    #[doc = " oaddr value."]
    #[doc = " @param [out] olen Actual length of an allocated area in bytes."]
    #[doc = " @param opts Allocation options bitmask flag @ref iwfs_fsm_aflags"]
    #[doc = " @return `0` on success or error code."]
    pub allocate: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FSM,
            len: off_t,
            oaddr: *mut off_t,
            olen: *mut off_t,
            opts: iwfs_fsm_aflags,
        ) -> iwrc,
    >,
    #[doc = " @brief Reallocate and adjust a size of an allocated block."]
    #[doc = ""]
    #[doc = " If the given @a nlen value lesser than actual length of segment @a olen in"]
    #[doc = " that case"]
    #[doc = " segment will be truncated."]
    #[doc = ""]
    #[doc = " @param f `IWFS_FSM` file."]
    #[doc = " @param nlen Desired length of segment in bytes."]
    #[doc = " @param oaddr [in,out] Address of an allocated segment. Placeholder for new"]
    #[doc = " address of reallocated segment."]
    #[doc = " @param olen [in,out] Length of an allocated segment. Placeholder for length"]
    #[doc = " of reallocated segment."]
    #[doc = " @param opts Allocation options bitmask flag @ref iwfs_fsm_aflags"]
    #[doc = " @return `0` on success or error code."]
    pub reallocate: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FSM,
            nlen: off_t,
            oaddr: *mut off_t,
            olen: *mut off_t,
            opts: iwfs_fsm_aflags,
        ) -> iwrc,
    >,
    #[doc = " @brief Free a previously allocated area."]
    #[doc = " @param addr Address space offset in bytes <em>it must be block size"]
    #[doc = " aligned</em>."]
    #[doc = " @param len Length of area to release."]
    #[doc = " @return `0` on success or error code."]
    pub deallocate: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FSM, addr: off_t, len: off_t) -> iwrc,
    >,
    #[doc = " @brief Check allocation status of region specified by @a addr and @a len"]
    #[doc = " @return `0` on success or error code."]
    pub check_allocation_status: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FSM, addr: off_t, len: off_t, allocated: bool) -> iwrc,
    >,
    #[doc = " @brief Write a data to the custom file header."]
    #[doc = ""]
    #[doc = " A custom file header size specified in IWFS_FSM_OPTS::hdrlen options on"]
    #[doc = " file creation."]
    #[doc = ""]
    #[doc = " @param off Offset position relative to custom header start offset."]
    #[doc = " @param buf Data buffer to write"]
    #[doc = " @param siz Number of bytes of @a buf to write into header."]
    #[doc = " @return `0` on success or error code."]
    pub writehdr: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FSM,
            off: off_t,
            buf: *const ::std::os::raw::c_void,
            siz: off_t,
        ) -> iwrc,
    >,
    #[doc = " @brief Read a data from the custom file header."]
    #[doc = ""]
    #[doc = " A custom file header size specified in IWFS_FSM_OPTS::hdrlen options on"]
    #[doc = " file creation."]
    #[doc = ""]
    #[doc = " @param off Offset position relative to custom header start offset."]
    #[doc = " @param [out] buf Data buffer to read into"]
    #[doc = " @param Number of bytes to read"]
    pub readhdr: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FSM,
            off: off_t,
            buf: *mut ::std::os::raw::c_void,
            siz: off_t,
        ) -> iwrc,
    >,
    #[doc = " @brief Cleanup all allocated data blocks and reset the file to the initial"]
    #[doc = " empty state."]
    #[doc = ""]
    #[doc = " @param clrflags"]
    #[doc = " @return `0` on success or error code."]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FSM, clrflags: iwfs_fsm_clrfalgs) -> iwrc,
    >,
    #[doc = " @see IWFS_EXT::ensure_size"]
    pub ensure_size:
        ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_FSM, size: off_t) -> iwrc>,
    #[doc = " @see IWFS_EXT::add_mmap"]
    pub add_mmap: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FSM,
            off: off_t,
            maxlen: usize,
            opts: iwfs_ext_mmap_opts_t,
        ) -> iwrc,
    >,
    #[doc = " @see IWFS_EXT::remap_all"]
    pub remap_all: ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_FSM) -> iwrc>,
    #[doc = " @brief Get a pointer to the registered mmap area starting at `off`."]
    #[doc = ""]
    #[doc = " WARNING: Internal read lock will be acquired and"]
    #[doc = "          must be released by subsequent `release_mmap()` call"]
    #[doc = "          after all activity with mmaped region has finished."]
    #[doc = ""]
    #[doc = " @see IWFS_FSM::add_mmap"]
    #[doc = " @see IWFS_EXT::acquire_mmap"]
    pub acquire_mmap: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FSM,
            off: off_t,
            mm: *mut *mut u8,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = " @brief Retrieve mmaped region by its offset @a off"]
    pub probe_mmap: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FSM,
            off: off_t,
            mm: *mut *mut u8,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = " @brief Release the lock acquired by successfull call of `acquire_mmap()`"]
    pub release_mmap: ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_FSM) -> iwrc>,
    #[doc = " @see IWFS_EXT::remove_mmap"]
    pub remove_mmap:
        ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_FSM, off: off_t) -> iwrc>,
    #[doc = " @see IWFS_EXT::sync_mmap"]
    pub sync_mmap: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FSM, off: off_t, flags: iwfs_sync_flags) -> iwrc,
    >,
    #[doc = " @see IWFS_FILE::write"]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FSM,
            off: off_t,
            buf: *const ::std::os::raw::c_void,
            siz: usize,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = " @see IWFS_FILE::read"]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut IWFS_FSM,
            off: off_t,
            buf: *mut ::std::os::raw::c_void,
            siz: usize,
            sp: *mut usize,
        ) -> iwrc,
    >,
    #[doc = " @see IWFS_FILE::close"]
    pub close: ::std::option::Option<unsafe extern "C" fn(f: *mut IWFS_FSM) -> iwrc>,
    #[doc = " @see IWFS_FILE::sync"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FSM, flags: iwfs_sync_flags) -> iwrc,
    >,
    #[doc = " @see IWFS_FILE::state"]
    pub state: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FSM, state: *mut IWFS_FSM_STATE) -> iwrc,
    >,
    #[doc = " get access to the underlying iwextfile instance"]
    pub extfile: ::std::option::Option<
        unsafe extern "C" fn(f: *mut IWFS_FSM, ext: *mut *mut IWFS_EXT) -> iwrc,
    >,
}
#[test]
fn bindgen_test_layout_IWFS_FSM() {
    assert_eq!(
        ::std::mem::size_of::<IWFS_FSM>(),
        176usize,
        concat!("Size of: ", stringify!(IWFS_FSM))
    );
    assert_eq!(
        ::std::mem::align_of::<IWFS_FSM>(),
        8usize,
        concat!("Alignment of ", stringify!(IWFS_FSM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).allocate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(allocate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).reallocate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(reallocate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).deallocate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(deallocate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IWFS_FSM>())).check_allocation_status as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(check_allocation_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).writehdr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(writehdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).readhdr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(readhdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).clear as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).ensure_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(ensure_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).add_mmap as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(add_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).remap_all as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(remap_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).acquire_mmap as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(acquire_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).probe_mmap as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(probe_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).release_mmap as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(release_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).remove_mmap as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(remove_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).sync_mmap as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(sync_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).write as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).read as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).close as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).sync as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).state as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWFS_FSM>())).extfile as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(IWFS_FSM),
            "::",
            stringify!(extfile)
        )
    );
}
extern "C" {
    #[doc = " @brief Open `IWFS_FSM` file."]
    #[doc = ""]
    #[doc = " <strong>Example:</strong>"]
    #[doc = ""]
    #[doc = " Open a buffer pool file for multithreaded env with fibonacci file resize"]
    #[doc = " policy with block size of 64 bytes and custom file header of 255 bytes"]
    #[doc = " length."]
    #[doc = ""]
    #[doc = " @code {.c}"]
    #[doc = "  IWFS_FSM_OPTS opts = {"]
    #[doc = "       .exfile = {"]
    #[doc = "          .file = {"]
    #[doc = "              .path       = \"myfile.dat\","]
    #[doc = "              .omode      = IWFS_OWRITE | IWFS_OCREATE,"]
    #[doc = "              .lock_mode  = IWP_WLOCK"]
    #[doc = "          },"]
    #[doc = "          .rspolicy       = iw_exfile_szpolicy_fibo"]
    #[doc = "        },"]
    #[doc = "       .bpow = 6,              // 2^6 bytes block size"]
    #[doc = "       .hdrlen = 255,          // Size of custom file header"]
    #[doc = "       .oflags = IWFSM_STRICT  // Use verbose free-space bitmap checking for"]
    #[doc = "                               // allocations (10-15% overhead)"]
    #[doc = "  };"]
    #[doc = ""]
    #[doc = "  IWFS_FSM f;"]
    #[doc = "  size_t sp;"]
    #[doc = "  off_t space_len, space_addr = 0;"]
    #[doc = ""]
    #[doc = "  iwrc rc = iwfs_fsmfile_open(&f, &opts);"]
    #[doc = ""]
    #[doc = "  //Allocate 2 blocks of file space"]
    #[doc = "  rc = f.allocate(&f, 128, &space_addr, &space_len, 0);"]
    #[doc = "  if (!rc) {"]
    #[doc = "      int data = 33;"]
    #[doc = "      // Write some data to the allocated block with writer lock acquired on"]
    #[doc = "      // `[space_addr, sizeof(data))`"]
    #[doc = "      rc = f.lwrite(&f, space_addr, &data, sizeof(data), &sp);"]
    #[doc = "      ..."]
    #[doc = "  }"]
    #[doc = "  ..."]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param f File handle"]
    #[doc = " @param opts File open options"]
    #[doc = " @relatesalso IWFS_FSM"]
    pub fn iwfs_fsmfile_open(f: *mut IWFS_FSM, opts: *const IWFS_FSM_OPTS) -> iwrc;
}
extern "C" {
    #[doc = " @brief Init `iwfsmfile` submodule."]
    pub fn iwfs_fsmfile_init() -> iwrc;
}
pub const iwkv_ecode__IWKV_ERROR_START: iwkv_ecode = 75000;
#[doc = "< Key not found (IWKV_ERROR_NOTFOUND)"]
pub const iwkv_ecode_IWKV_ERROR_NOTFOUND: iwkv_ecode = 75001;
#[doc = "< Key already exists (IWKV_ERROR_KEY_EXISTS)"]
pub const iwkv_ecode_IWKV_ERROR_KEY_EXISTS: iwkv_ecode = 75002;
pub const iwkv_ecode_IWKV_ERROR_MAXKVSZ: iwkv_ecode = 75003;
#[doc = "< Database file invalid or corrupted (IWKV_ERROR_CORRUPTED)"]
pub const iwkv_ecode_IWKV_ERROR_CORRUPTED: iwkv_ecode = 75004;
pub const iwkv_ecode_IWKV_ERROR_DUP_VALUE_SIZE: iwkv_ecode = 75005;
pub const iwkv_ecode_IWKV_ERROR_KEY_NUM_VALUE_SIZE: iwkv_ecode = 75006;
#[doc = "< Incorpatible database open mode (IWKV_ERROR_INCOMPATIBLE_DB_MODE)"]
pub const iwkv_ecode_IWKV_ERROR_INCOMPATIBLE_DB_MODE: iwkv_ecode = 75007;
pub const iwkv_ecode_IWKV_ERROR_INCOMPATIBLE_DB_FORMAT: iwkv_ecode = 75008;
#[doc = "< Corrupted WAL file (IWKV_ERROR_CORRUPTED_WAL_FILE)"]
pub const iwkv_ecode_IWKV_ERROR_CORRUPTED_WAL_FILE: iwkv_ecode = 75009;
pub const iwkv_ecode_IWKV_ERROR_VALUE_CANNOT_BE_INCREMENTED: iwkv_ecode = 75010;
pub const iwkv_ecode_IWKV_ERROR_WAL_MODE_REQUIRED: iwkv_ecode = 75011;
#[doc = "< Backup operation in progress. (IWKV_ERROR_BACKUP_IN_PROGRESS)"]
pub const iwkv_ecode_IWKV_ERROR_BACKUP_IN_PROGRESS: iwkv_ecode = 75012;
pub const iwkv_ecode__IWKV_ERROR_END: iwkv_ecode = 75013;
pub const iwkv_ecode__IWKV_RC_KVBLOCK_FULL: iwkv_ecode = 75014;
pub const iwkv_ecode__IWKV_RC_REQUIRE_NLEVEL: iwkv_ecode = 75015;
pub const iwkv_ecode__IWKV_RC_END: iwkv_ecode = 75016;
#[doc = " @brief IWKV error codes."]
pub type iwkv_ecode = u32;
#[doc = " Database file open modes."]
pub type iwkv_openflags = u8;
#[doc = " Database initialization modes"]
pub type iwdb_flags_t = u8;
#[doc = "  Record store modes used in `iwkv_put()` and `iwkv_cursor_set()` functions."]
pub type iwkv_opflags = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IWKV {
    _unused: [u8; 0],
}
pub type IWKV = *mut _IWKV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IWDB {
    _unused: [u8; 0],
}
pub type IWDB = *mut _IWDB;
#[doc = " @brief Write ahead log (WAL) options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWKV_WAL_OPTS {
    #[doc = "< WAL enabled"]
    pub enabled: bool,
    #[doc = "< Check CRC32 sum of data blocks during checkpoint. Default: false"]
    pub check_crc_on_checkpoint: bool,
    #[doc = "< Savepoint timeout seconds. Default: 10 sec"]
    pub savepoint_timeout_sec: u32,
    #[doc = "< Checkpoint timeout seconds. Default: 300 sec (5 min);"]
    pub checkpoint_timeout_sec: u32,
    #[doc = "< WAL file intermediate buffer size. Default: 8Mb"]
    pub wal_buffer_sz: usize,
    #[doc = "< Checkpoint buffer size in bytes. Default: 1Gb"]
    pub checkpoint_buffer_sz: u64,
    pub wal_lock_interceptor: ::std::option::Option<
        unsafe extern "C" fn(arg1: bool, arg2: *mut ::std::os::raw::c_void) -> iwrc,
    >,
    #[doc = "< Opaque data for `wal_lock_interceptor`"]
    pub wal_lock_interceptor_opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_IWKV_WAL_OPTS() {
    assert_eq!(
        ::std::mem::size_of::<IWKV_WAL_OPTS>(),
        48usize,
        concat!("Size of: ", stringify!(IWKV_WAL_OPTS))
    );
    assert_eq!(
        ::std::mem::align_of::<IWKV_WAL_OPTS>(),
        8usize,
        concat!("Alignment of ", stringify!(IWKV_WAL_OPTS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_WAL_OPTS>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_WAL_OPTS),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IWKV_WAL_OPTS>())).check_crc_on_checkpoint as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_WAL_OPTS),
            "::",
            stringify!(check_crc_on_checkpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IWKV_WAL_OPTS>())).savepoint_timeout_sec as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_WAL_OPTS),
            "::",
            stringify!(savepoint_timeout_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IWKV_WAL_OPTS>())).checkpoint_timeout_sec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_WAL_OPTS),
            "::",
            stringify!(checkpoint_timeout_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_WAL_OPTS>())).wal_buffer_sz as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_WAL_OPTS),
            "::",
            stringify!(wal_buffer_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IWKV_WAL_OPTS>())).checkpoint_buffer_sz as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_WAL_OPTS),
            "::",
            stringify!(checkpoint_buffer_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IWKV_WAL_OPTS>())).wal_lock_interceptor as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_WAL_OPTS),
            "::",
            stringify!(wal_lock_interceptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IWKV_WAL_OPTS>())).wal_lock_interceptor_opaque as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_WAL_OPTS),
            "::",
            stringify!(wal_lock_interceptor_opaque)
        )
    );
}
#[doc = " @brief IWKV storage open options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWKV_OPTS {
    #[doc = "< Path to database file"]
    pub path: *const ::std::os::raw::c_char,
    #[doc = "< Random seed used for iwu random generator"]
    pub random_seed: u32,
    #[doc = " Database storage format version."]
    #[doc = " Leave it as zero for the latest supported format."]
    #[doc = " Used only for newly created databases,"]
    pub fmt_version: i32,
    #[doc = "< Bitmask of database file open modes"]
    pub oflags: iwkv_openflags,
    #[doc = "< Do not wait and raise error if database is locked by another process"]
    pub file_lock_fail_fast: bool,
    #[doc = "< WAL options"]
    pub wal: IWKV_WAL_OPTS,
}
#[test]
fn bindgen_test_layout_IWKV_OPTS() {
    assert_eq!(
        ::std::mem::size_of::<IWKV_OPTS>(),
        72usize,
        concat!("Size of: ", stringify!(IWKV_OPTS))
    );
    assert_eq!(
        ::std::mem::align_of::<IWKV_OPTS>(),
        8usize,
        concat!("Alignment of ", stringify!(IWKV_OPTS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_OPTS>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_OPTS),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_OPTS>())).random_seed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_OPTS),
            "::",
            stringify!(random_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_OPTS>())).fmt_version as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_OPTS),
            "::",
            stringify!(fmt_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_OPTS>())).oflags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_OPTS),
            "::",
            stringify!(oflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_OPTS>())).file_lock_fail_fast as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_OPTS),
            "::",
            stringify!(file_lock_fail_fast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_OPTS>())).wal as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_OPTS),
            "::",
            stringify!(wal)
        )
    );
}
#[doc = " @brief Data container for key/value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWKV_val {
    #[doc = "< Data buffer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Data buffer size"]
    pub size: usize,
    #[doc = " Extra key part used for key comparison."]
    #[doc = "  If set to non zero and database is created with `IWDB_COMPOUND_KEYS` mode"]
    #[doc = "  keys will behave as compound: `<key value><compound>` consisting of two parts."]
    #[doc = "  `compound` field ignored if db not in `IWDB_COMPOUND_KEYS` mode."]
    pub compound: i64,
}
#[test]
fn bindgen_test_layout_IWKV_val() {
    assert_eq!(
        ::std::mem::size_of::<IWKV_val>(),
        24usize,
        concat!("Size of: ", stringify!(IWKV_val))
    );
    assert_eq!(
        ::std::mem::align_of::<IWKV_val>(),
        8usize,
        concat!("Alignment of ", stringify!(IWKV_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_val>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_val),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_val>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_val),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IWKV_val>())).compound as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWKV_val),
            "::",
            stringify!(compound)
        )
    );
}
#[doc = " @brief Cursor opaque handler."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IWKV_cursor {
    _unused: [u8; 0],
}
pub type IWKV_cursor = *mut _IWKV_cursor;
#[doc = "< Set cursor to position before first record"]
pub const IWKV_cursor_op_IWKV_CURSOR_BEFORE_FIRST: IWKV_cursor_op = 1;
#[doc = "< Set cursor to position after last record"]
pub const IWKV_cursor_op_IWKV_CURSOR_AFTER_LAST: IWKV_cursor_op = 2;
#[doc = "< Move cursor to the next record"]
pub const IWKV_cursor_op_IWKV_CURSOR_NEXT: IWKV_cursor_op = 3;
#[doc = "< Move cursor to the previous record"]
pub const IWKV_cursor_op_IWKV_CURSOR_PREV: IWKV_cursor_op = 4;
#[doc = "< Set cursor to the specified key value"]
pub const IWKV_cursor_op_IWKV_CURSOR_EQ: IWKV_cursor_op = 5;
#[doc = "< Set cursor to the key which greater or equal key specified"]
pub const IWKV_cursor_op_IWKV_CURSOR_GE: IWKV_cursor_op = 6;
#[doc = " @brief Database cursor operations and position flags."]
pub type IWKV_cursor_op = u32;
extern "C" {
    #[doc = " @brief Initialize iwkv storage."]
    #[doc = " @details This method must be called before using of any iwkv public API function."]
    #[doc = " @note iwkv implicitly initialized by iw_init()"]
    pub fn iwkv_init() -> iwrc;
}
extern "C" {
    #[doc = " @brief Open iwkv storage."]
    #[doc = " @code {.c}"]
    #[doc = "  IWKV iwkv;"]
    #[doc = "  IWKV_OPTS opts = {"]
    #[doc = "    .path = \"mystore.db\""]
    #[doc = "  };"]
    #[doc = "  iwrc rc = iwkv_open(&opts, &iwkv);"]
    #[doc = " @endcode"]
    #[doc = " @note Any opened iwkv storage must be closed by `iwkv_close()` after usage."]
    #[doc = " @param opts Database open options."]
    #[doc = " @param [out] iwkvp Pointer to @ref IWKV structure."]
    pub fn iwkv_open(opts: *const IWKV_OPTS, iwkvp: *mut IWKV) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get iwkv database handler identified by specified `dbid` number."]
    #[doc = " @details In the case if no database matched `dbid`"]
    #[doc = "          a new database will be created using specified function arguments."]
    #[doc = ""]
    #[doc = " @note Database handler doesn't require to be explicitly closed or freed."]
    #[doc = "       Although it may be usefull to release database cache memory of unused databases"]
    #[doc = "       dependening on memory requirements of your application by `iwkv_db_cache_release()`."]
    #[doc = " @note Database `flags` argument must be same for all subsequent"]
    #[doc = "       calls after first call for particular database,"]
    #[doc = "       otherwise `IWKV_ERROR_INCOMPATIBLE_DB_MODE` will be reported."]
    #[doc = ""]
    #[doc = " @param iwkv Pointer to @ref IWKV handler"]
    #[doc = " @param dbid Database identifier"]
    #[doc = " @param flags Database initialization flags"]
    #[doc = " @param [out] dbp Pointer to database opaque structure"]
    pub fn iwkv_db(iwkv: IWKV, dbid: u32, flags: iwdb_flags_t, dbp: *mut IWDB) -> iwrc;
}
extern "C" {
    #[doc = " @brief Create new database with next available database id."]
    #[doc = " @see iwrc iwkv_db()"]
    #[doc = ""]
    #[doc = " @param flags Database initialization flags"]
    #[doc = " @param [out] dbidp Database identifier placeholder will be filled with next available id."]
    #[doc = " @param [out] dbp Pointer to database opaque structure"]
    pub fn iwkv_new_db(iwkv: IWKV, dbflg: iwdb_flags_t, dbidp: *mut u32, dbp: *mut IWDB) -> iwrc;
}
extern "C" {
    #[doc = " @brief Frees memory resources used by database cache"]
    #[doc = "        until to next database access operation (get/put/cursor)."]
    #[doc = "        Typicaly it will free ~130Kb of memory per database in use."]
    #[doc = ""]
    #[doc = " @param db Database handler"]
    pub fn iwkv_db_cache_release(db: IWDB) -> iwrc;
}
extern "C" {
    #[doc = " @brief Destroy(drop) existing database and cleanup all of its data."]
    #[doc = ""]
    #[doc = " @param dbp Pointer to database opened."]
    pub fn iwkv_db_destroy(dbp: *mut IWDB) -> iwrc;
}
extern "C" {
    #[doc = " @brief Sync iwkv storage state with disk."]
    #[doc = ""]
    #[doc = " @note It will cause deadlock if current thread holds opened cursors and WAL is enabled,"]
    #[doc = "       use method with caution."]
    #[doc = ""]
    #[doc = " @param iwkv IWKV handler."]
    #[doc = " @param flags Sync flags."]
    pub fn iwkv_sync(iwkv: IWKV, flags: iwfs_sync_flags) -> iwrc;
}
extern "C" {
    #[doc = " @brief Close iwkv storage."]
    #[doc = " @details Upon successfull call of iwkv_close()"]
    #[doc = " no farther operations on storage or any of its databases are allowed."]
    #[doc = ""]
    #[doc = " @param iwkvp"]
    pub fn iwkv_close(iwkvp: *mut IWKV) -> iwrc;
}
extern "C" {
    #[doc = " @brief Store record in database."]
    #[doc = ""]
    #[doc = " iwkv_opflags opflags:"]
    #[doc = " - `IWKV_NO_OVERWRITE` If a key is already exists the `IWKV_ERROR_KEY_EXISTS` error will returned."]
    #[doc = " - `IWKV_SYNC` Flush changes on disk after operation"]
    #[doc = ""]
    #[doc = " @note `iwkv_put()` adds a new value to sorted values array for existing keys if"]
    #[doc = " database created with `IWDB_DUP_UINT32_VALS`|`IWDB_DUP_UINT64_VALS` flags"]
    #[doc = ""]
    #[doc = " @param db Database handler"]
    #[doc = " @param key Key data container"]
    #[doc = " @param val Value data container"]
    #[doc = " @param opflags Put options used"]
    pub fn iwkv_put(
        db: IWDB,
        key: *const IWKV_val,
        val: *const IWKV_val,
        opflags: iwkv_opflags,
    ) -> iwrc;
}
#[doc = " @brief Intercepts old(replaced) value in put operation."]
#[doc = " @note If `oldval` is not zero IWKV_PUT_HANDLER responsive for releasing it using iwkv_val_dispose()"]
#[doc = " @warning Use `IWKV_PUT_HANDLER` with caution: mind deadlocks."]
#[doc = ""]
#[doc = " @param key Key used in put operation"]
#[doc = " @param val Value used in put operation"]
#[doc = " @param oldval Old value which will be replaced by `val` may be `NULL`"]
#[doc = " @param op Arbitrary opaqued data passed to this handler"]
pub type IWKV_PUT_HANDLER = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const IWKV_val,
        val: *const IWKV_val,
        oldval: *mut IWKV_val,
        op: *mut ::std::os::raw::c_void,
    ) -> iwrc,
>;
extern "C" {
    #[doc = " @brief Store record in database."]
    #[doc = " @see iwkv_put()"]
    pub fn iwkv_puth(
        db: IWDB,
        key: *const IWKV_val,
        val: *const IWKV_val,
        opflags: iwkv_opflags,
        ph: IWKV_PUT_HANDLER,
        phop: *mut ::std::os::raw::c_void,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get value for given `key`."]
    #[doc = ""]
    #[doc = " @note If not matching record found `IWKV_ERROR_NOTFOUND` will be returned."]
    #[doc = " @note On success a returned value must be freed with `iwkv_val_dispose()`"]
    #[doc = ""]
    #[doc = " @param db Database handler"]
    #[doc = " @param key Key data"]
    #[doc = " @param [out] oval Value associated with `key` or `NULL`"]
    pub fn iwkv_get(db: IWDB, key: *const IWKV_val, oval: *mut IWKV_val) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get value for given `key` and copy it into provided `vbuf` using up to `vbufsz` bytes."]
    #[doc = ""]
    #[doc = " @param db Database handler"]
    #[doc = " @param key Key data"]
    #[doc = " @param vbuf Pointer to value buffer"]
    #[doc = " @param vbufsz Value buffer size"]
    #[doc = " @param [out] vsz Actual value size"]
    pub fn iwkv_get_copy(
        db: IWDB,
        key: *const IWKV_val,
        vbuf: *mut ::std::os::raw::c_void,
        vbufsz: usize,
        vsz: *mut usize,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Set arbitrary data associated with database."]
    #[doc = " Database write lock will acquired for this operation."]
    #[doc = ""]
    #[doc = " @param db Database handler"]
    #[doc = " @param buf Data buffer"]
    #[doc = " @param sz  Size of data buffer"]
    pub fn iwkv_db_set_meta(db: IWDB, buf: *mut ::std::os::raw::c_void, sz: usize) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get arbitrary data associated with database."]
    #[doc = " @param db Database handler"]
    #[doc = " @param buf Output buffer"]
    #[doc = " @param sz Size of target buffer"]
    #[doc = " @param [out] rsz Number of bytes read actually"]
    pub fn iwkv_db_get_meta(
        db: IWDB,
        buf: *mut ::std::os::raw::c_void,
        sz: usize,
        rsz: *mut usize,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Remove record identified by `key`."]
    #[doc = ""]
    #[doc = " Returns `IWKV_ERROR_NOTFOUND` is no matching key found"]
    #[doc = " @param db Database handler"]
    #[doc = " @param key Key data container"]
    pub fn iwkv_del(db: IWDB, key: *const IWKV_val, opflags: iwkv_opflags) -> iwrc;
}
extern "C" {
    #[doc = " @brief Destroy key/value data container."]
    #[doc = ""]
    pub fn iwkv_val_dispose(kval: *mut IWKV_val);
}
extern "C" {
    #[doc = " @brief Dispose data containers for key and value respectively."]
    #[doc = ""]
    #[doc = " @note This method is shortland of:"]
    #[doc = " @code {.c}"]
    #[doc = "  iwkv_kv_dispose(key);"]
    #[doc = "  iwkv_kv_dispose(val);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param key Key data containers"]
    #[doc = " @param val Value data containers"]
    pub fn iwkv_kv_dispose(key: *mut IWKV_val, val: *mut IWKV_val);
}
extern "C" {
    #[doc = " @brief Open database cursor."]
    #[doc = ""]
    #[doc = " @param db Database handler"]
    #[doc = " @param cur Pointer to an allocated cursor structure to be initialized"]
    #[doc = " @param op Cursor open mode/initial positions flags"]
    #[doc = " @param key Optional key argument, required to point cursor to the given key."]
    pub fn iwkv_cursor_open(
        db: IWDB,
        cur: *mut IWKV_cursor,
        op: IWKV_cursor_op,
        key: *const IWKV_val,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Move cursor to the next position."]
    #[doc = ""]
    #[doc = " @param cur Opened cursor object"]
    #[doc = " @param op Cursor position operation"]
    pub fn iwkv_cursor_to(cur: IWKV_cursor, op: IWKV_cursor_op) -> iwrc;
}
extern "C" {
    #[doc = " @brief Move cursor to the next position."]
    #[doc = ""]
    #[doc = " @param cur Opened cursor object"]
    #[doc = " @param op Cursor position operation"]
    #[doc = " @param key Optional key argument used to move cursor to the given key."]
    pub fn iwkv_cursor_to_key(cur: IWKV_cursor, op: IWKV_cursor_op, key: *const IWKV_val) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get key and value at current cursor position."]
    #[doc = " @note Data stored in okey/oval containers must be freed with `iwkv_val_dispose()`."]
    #[doc = ""]
    #[doc = " @param cur Opened cursor object"]
    #[doc = " @param okey Key container to be initialized by key at current position. Can be null."]
    #[doc = " @param oval Value container to be initialized by value at current position. Can be null."]
    pub fn iwkv_cursor_get(cur: IWKV_cursor, okey: *mut IWKV_val, oval: *mut IWKV_val) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get value at current cursor position."]
    #[doc = " @note Data stored in `oval` container must be freed with `iwkv_val_dispose()`."]
    #[doc = " @param cur Opened cursor object"]
    #[doc = " @param oval Value holder to be initialized by value at current position"]
    pub fn iwkv_cursor_val(cur: IWKV_cursor, oval: *mut IWKV_val) -> iwrc;
}
extern "C" {
    #[doc = " @brief Copy value data to the specified buffer at the current cursor position."]
    #[doc = " @note At most of `bufsz` bytes will be copied into `vbuf`."]
    #[doc = ""]
    #[doc = " @param cur Opened cursor object"]
    #[doc = " @param vbuf Pointer to value buffer"]
    #[doc = " @param vbufsz Value buffer size"]
    #[doc = " @param [out] vsz Actual value size"]
    pub fn iwkv_cursor_copy_val(
        cur: IWKV_cursor,
        vbuf: *mut ::std::os::raw::c_void,
        vbufsz: usize,
        vsz: *mut usize,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get key at current cursor position."]
    #[doc = " @note Data stored in okey container must be freed with `iwkv_val_dispose()`."]
    #[doc = ""]
    #[doc = " @param cur Opened cursor object"]
    #[doc = " @param oval Key holder to be initialized by key at current position"]
    pub fn iwkv_cursor_key(cur: IWKV_cursor, okey: *mut IWKV_val) -> iwrc;
}
extern "C" {
    #[doc = " @brief Copy key data to the specified buffer at the current cursor position."]
    #[doc = " @note At most of `bufsz` bytes will be copied into `kbuf`."]
    #[doc = ""]
    #[doc = " @param cur Opened cursor object"]
    #[doc = " @param kbuf Pointer to value buffer, can be zero if kbufsz is zero too."]
    #[doc = " @param kbufsz Key buffer size, cab be zero."]
    #[doc = " @param [out] ksz Actual key size"]
    #[doc = " @param [out] compound Compound key part value, can be zero."]
    pub fn iwkv_cursor_copy_key(
        cur: IWKV_cursor,
        kbuf: *mut ::std::os::raw::c_void,
        kbufsz: usize,
        ksz: *mut usize,
        compound: *mut i64,
    ) -> iwrc;
}
extern "C" {
    pub fn iwkv_cursor_is_matched_key(
        cur: IWKV_cursor,
        key: *const IWKV_val,
        ores: *mut bool,
        ocompound: *mut i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Set record value at current cursor position."]
    #[doc = " @note This is equivalent to `iwkv_put()` operation."]
    #[doc = ""]
    #[doc = " iwkv_opflags opflags:"]
    #[doc = " - `IWKV_NO_OVERWRITE` If a key is already exists the `IWKV_ERROR_KEY_EXISTS` error will returned."]
    #[doc = " - `IWKV_SYNC` Flush changes on disk after operation"]
    #[doc = ""]
    #[doc = " @note `iwkv_cursor_set()` adds a new value to sorted values array for existing keys if"]
    #[doc = " database created with `IWDB_DUP_UINT32_VALS`|`IWDB_DUP_UINT64_VALS` flags"]
    #[doc = ""]
    #[doc = " @param cur Opened cursor object"]
    #[doc = " @param val Value holder"]
    #[doc = " @param opflags Update value mode"]
    pub fn iwkv_cursor_set(cur: IWKV_cursor, val: *mut IWKV_val, opflags: iwkv_opflags) -> iwrc;
}
extern "C" {
    pub fn iwkv_cursor_seth(
        cur: IWKV_cursor,
        val: *mut IWKV_val,
        opflags: iwkv_opflags,
        ph: IWKV_PUT_HANDLER,
        phop: *mut ::std::os::raw::c_void,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Remove record value at current cursor position."]
    #[doc = " @param cur Opened cursor object"]
    pub fn iwkv_cursor_del(cur: IWKV_cursor, opflags: iwkv_opflags) -> iwrc;
}
extern "C" {
    #[doc = " @brief Close cursor object."]
    #[doc = " @param cur Opened cursor"]
    pub fn iwkv_cursor_close(cur: *mut IWKV_cursor) -> iwrc;
}
extern "C" {
    #[doc = " Creates an online database backup image and copies it into the specified `target_file`."]
    #[doc = " During online backup phase read/write database operations are not"]
    #[doc = " blocked for significant amount of time. Backup finish time is"]
    #[doc = " placed into `ts` as number of milliseconds since epoch."]
    #[doc = " Online backup guaranties what all records before `ts` timestamp will"]
    #[doc = " be stored in backup image. Later, online backup image can be"]
    #[doc = " opened as ordinary database file."]
    #[doc = ""]
    #[doc = " @note In order to avoid deadlocks: close all opened database cursors"]
    #[doc = " before calling this method."]
    #[doc = ""]
    #[doc = " @param iwkv"]
    #[doc = " @param [out] ts Backup completion timestamp"]
    #[doc = " @param target_file backup file path"]
    pub fn iwkv_online_backup(
        iwkv: IWKV,
        ts: *mut u64,
        target_file: *const ::std::os::raw::c_char,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get database file status info."]
    #[doc = " @note Database should be in opened state."]
    #[doc = ""]
    #[doc = " @see IWFS_FILE::state"]
    #[doc = " @param db Database handler"]
    #[doc = " @param [out] out IWFS_FSM_STATE placeholder iwkv file state"]
    pub fn iwkv_state(iwkv: IWKV, out: *mut IWFS_FSM_STATE) -> iwrc;
}
extern "C" {
    pub fn iwkvd_db(
        f: *mut FILE,
        db: IWDB,
        flags: ::std::os::raw::c_int,
        plvl: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IWPOOL {
    _unused: [u8; 0],
}
pub type IWPOOL = _IWPOOL;
extern "C" {
    #[doc = " @brief Creates memory pool and preallocate initial buffer of size `siz` bytes."]
    #[doc = " In the case if `siz` is zero then size of initial memory buffer will be `IWPOOL_POOL_SIZ` bytes."]
    #[doc = ""]
    #[doc = " @param siz Initial memory buffer size. Can be zero."]
    #[doc = " @return Pointer to the new pool or `zero` if allocation is failed."]
    pub fn iwpool_create(siz: usize) -> *mut IWPOOL;
}
extern "C" {
    #[doc = " @brief Create empty pool with no preallocated buffer."]
    #[doc = " @return Pointer to the new pool or `zero` if allocation is failed."]
    pub fn iwpool_create_empty() -> *mut IWPOOL;
}
extern "C" {
    #[doc = " @brief Allocates buffer of specified size."]
    #[doc = ""]
    #[doc = " @param siz  Size of buffer."]
    #[doc = " @param pool Pointer to memory pool."]
    #[doc = " @return Pointer to buffer or `zero` if allocation is failed."]
    pub fn iwpool_alloc(siz: usize, pool: *mut IWPOOL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Allocates zero initialized memory buffer"]
    #[doc = "        and initializes allocated buffer with zeroes."]
    #[doc = ""]
    #[doc = " @param siz Size of buffer."]
    #[doc = " @param pool Pointer to memory pool."]
    #[doc = " @return Pointer to buffer or `zero` if allocation is failed."]
    pub fn iwpool_calloc(siz: usize, pool: *mut IWPOOL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Copy a given `str` of size `len` into memory pool."]
    #[doc = ""]
    #[doc = " @param pool Pointer to memory pool."]
    #[doc = " @param str Pointer to buffer to copy."]
    #[doc = " @param len Size of buffer in bytes."]
    #[doc = " @param rcp Pointer to status code holder."]
    #[doc = " @return Pointer to copied buffer or `zero` if operation failed."]
    pub fn iwpool_strndup(
        pool: *mut IWPOOL,
        str: *const ::std::os::raw::c_char,
        len: usize,
        rcp: *mut iwrc,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Copy a given zero terminated char buffer into memory pool."]
    #[doc = ""]
    #[doc = " @param pool Pointer to memory pool."]
    #[doc = " @param str Zero terminated char buffer."]
    #[doc = " @param rcp Pointer to status code holder."]
    #[doc = " @return Pointer to copied buffer or `zero` if operation failed."]
    pub fn iwpool_strdup(
        pool: *mut IWPOOL,
        str: *const ::std::os::raw::c_char,
        rcp: *mut iwrc,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iwpool_strdup2(
        pool: *mut IWPOOL,
        str: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iwpool_strndup2(
        pool: *mut IWPOOL,
        str: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Do `fprintf` into string allocated in this memory pool."]
    #[doc = ""]
    #[doc = " @param pool Pointer to memory pool."]
    #[doc = " @param format `fprintf` format specification."]
    #[doc = " @param ..."]
    #[doc = " @return Pointer to resulted string of `zero` if operation is failed."]
    pub fn iwpool_printf(
        pool: *mut IWPOOL,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iwpool_split_string(
        pool: *mut IWPOOL,
        haystack: *const ::std::os::raw::c_char,
        split_chars: *const ::std::os::raw::c_char,
        ignore_whitespace: bool,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iwpool_printf_split(
        pool: *mut IWPOOL,
        split_chars: *const ::std::os::raw::c_char,
        ignore_whitespace: bool,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Destroys a given memory pool and frees its resources."]
    #[doc = ""]
    #[doc = " @param pool"]
    #[doc = " @return IW_EXPORT"]
    pub fn iwpool_destroy(pool: *mut IWPOOL);
}
extern "C" {
    #[doc = " @brief Dispose function for `IWPOOL` stored as user data."]
    #[doc = ""]
    #[doc = " @param pool Memory pool to be destroyed."]
    pub fn iwpool_free_fn(pool: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Sets arbitrary user data associated with this pool."]
    #[doc = "        User data will be freed on pool destroy or new user data set."]
    #[doc = ""]
    #[doc = " @param pool Pointer to memory pool."]
    #[doc = " @param data User data. Can be zero."]
    #[doc = " @param free_fn User data dispose function. Can be zero."]
    pub fn iwpool_user_data_set(
        pool: *mut IWPOOL,
        data: *mut ::std::os::raw::c_void,
        free_fn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = " @brief Returns pointer to user data associated with this pool. Or zero."]
    pub fn iwpool_user_data_get(pool: *mut IWPOOL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Reset user data free function for current user data stored in pool."]
    #[doc = ""]
    #[doc = " @param pool Pointer to memory pool."]
    #[doc = " @return Pointer to current user data stored or zero,"]
    pub fn iwpool_user_data_detach(pool: *mut IWPOOL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Returns number of bytes allocated for this memory pool."]
    #[doc = ""]
    #[doc = " @param pool Pointer to memory pool."]
    pub fn iwpool_allocated_size(pool: *mut IWPOOL) -> usize;
}
extern "C" {
    #[doc = " @brief Returns number of bytes actually used for allocated buffers."]
    #[doc = ""]
    #[doc = " @param pool Pointer to mmemory pool."]
    pub fn iwpool_used_size(pool: *mut IWPOOL) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IWXSTR {
    _unused: [u8; 0],
}
pub type IWXSTR = _IWXSTR;
extern "C" {
    pub fn iwxstr_new() -> *mut IWXSTR;
}
extern "C" {
    pub fn iwxstr_new2(siz: usize) -> *mut IWXSTR;
}
extern "C" {
    pub fn iwxstr_wrap(buf: *const ::std::os::raw::c_char, size: usize) -> *mut IWXSTR;
}
extern "C" {
    pub fn iwxstr_destroy(xstr: *mut IWXSTR);
}
extern "C" {
    pub fn iwxstr_destroy_keep_ptr(xstr: *mut IWXSTR);
}
extern "C" {
    pub fn iwxstr_cat(xstr: *mut IWXSTR, buf: *const ::std::os::raw::c_void, size: usize) -> iwrc;
}
extern "C" {
    pub fn iwxstr_cat2(xstr: *mut IWXSTR, buf: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    pub fn iwxstr_unshift(
        xstr: *mut IWXSTR,
        buf: *const ::std::os::raw::c_void,
        size: usize,
    ) -> iwrc;
}
extern "C" {
    pub fn iwxstr_printf(xstr: *mut IWXSTR, format: *const ::std::os::raw::c_char, ...) -> iwrc;
}
extern "C" {
    pub fn iwxstr_shift(xstr: *mut IWXSTR, shift_size: usize);
}
extern "C" {
    pub fn iwxstr_pop(xstr: *mut IWXSTR, pop_size: usize);
}
extern "C" {
    pub fn iwxstr_ptr(xstr: *mut IWXSTR) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iwxstr_set_size(xstr: *mut IWXSTR, size: usize) -> iwrc;
}
extern "C" {
    pub fn iwxstr_size(xstr: *mut IWXSTR) -> usize;
}
extern "C" {
    pub fn iwxstr_user_data_set(
        xstr: *mut IWXSTR,
        data: *mut ::std::os::raw::c_void,
        free_fn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn iwxstr_user_data_get(xstr: *mut IWXSTR) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn iwxstr_user_data_detach(xstr: *mut IWXSTR) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn iwxstr_clear(xstr: *mut IWXSTR);
}
#[doc = " @brief JSON document in compact binary format [Binn](https://github.com/liteserver/binn)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JBL {
    _unused: [u8; 0],
}
pub type JBL = *mut _JBL;
pub const jbl_ecode_t__JBL_ERROR_START: jbl_ecode_t = 86000;
#[doc = "< Invalid JBL buffer (JBL_ERROR_INVALID_BUFFER)"]
pub const jbl_ecode_t_JBL_ERROR_INVALID_BUFFER: jbl_ecode_t = 86001;
#[doc = "< Cannot create JBL object (JBL_ERROR_CREATION)"]
pub const jbl_ecode_t_JBL_ERROR_CREATION: jbl_ecode_t = 86002;
#[doc = "< Invalid JBL object (JBL_ERROR_INVALID)"]
pub const jbl_ecode_t_JBL_ERROR_INVALID: jbl_ecode_t = 86003;
#[doc = "< Failed to parse JSON string (JBL_ERROR_PARSE_JSON)"]
pub const jbl_ecode_t_JBL_ERROR_PARSE_JSON: jbl_ecode_t = 86004;
#[doc = "< Unquoted JSON string (JBL_ERROR_PARSE_UNQUOTED_STRING)"]
pub const jbl_ecode_t_JBL_ERROR_PARSE_UNQUOTED_STRING: jbl_ecode_t = 86005;
pub const jbl_ecode_t_JBL_ERROR_PARSE_INVALID_CODEPOINT: jbl_ecode_t = 86006;
#[doc = "< Invalid utf8 string (JBL_ERROR_PARSE_INVALID_UTF8)"]
pub const jbl_ecode_t_JBL_ERROR_PARSE_INVALID_UTF8: jbl_ecode_t = 86007;
#[doc = "< Invalid JSON pointer (rfc6901) path (JBL_ERROR_JSON_POINTER)"]
pub const jbl_ecode_t_JBL_ERROR_JSON_POINTER: jbl_ecode_t = 86008;
#[doc = "< JSON object not matched the path specified (JBL_ERROR_PATH_NOTFOUND)"]
pub const jbl_ecode_t_JBL_ERROR_PATH_NOTFOUND: jbl_ecode_t = 86009;
#[doc = "< Invalid JSON patch specified (JBL_ERROR_PATCH_INVALID)"]
pub const jbl_ecode_t_JBL_ERROR_PATCH_INVALID: jbl_ecode_t = 86010;
#[doc = "< Invalid JSON patch operation specified (JBL_ERROR_PATCH_INVALID_OP)"]
pub const jbl_ecode_t_JBL_ERROR_PATCH_INVALID_OP: jbl_ecode_t = 86011;
#[doc = "< No value specified in JSON patch (JBL_ERROR_PATCH_NOVALUE)"]
pub const jbl_ecode_t_JBL_ERROR_PATCH_NOVALUE: jbl_ecode_t = 86012;
pub const jbl_ecode_t_JBL_ERROR_PATCH_TARGET_INVALID: jbl_ecode_t = 86013;
#[doc = "< Invalid value specified by patch (JBL_ERROR_PATCH_INVALID_VALUE)"]
pub const jbl_ecode_t_JBL_ERROR_PATCH_INVALID_VALUE: jbl_ecode_t = 86014;
pub const jbl_ecode_t_JBL_ERROR_PATCH_INVALID_ARRAY_INDEX: jbl_ecode_t = 86015;
#[doc = "< JBL is not an object (JBL_ERROR_NOT_AN_OBJECT)"]
pub const jbl_ecode_t_JBL_ERROR_NOT_AN_OBJECT: jbl_ecode_t = 86016;
pub const jbl_ecode_t_JBL_ERROR_TYPE_MISMATCHED: jbl_ecode_t = 86017;
#[doc = "< JSON patch test operation failed (JBL_ERROR_PATCH_TEST_FAILED)"]
pub const jbl_ecode_t_JBL_ERROR_PATCH_TEST_FAILED: jbl_ecode_t = 86018;
pub const jbl_ecode_t_JBL_ERROR_MAX_NESTING_LEVEL_EXCEEDED: jbl_ecode_t = 86019;
pub const jbl_ecode_t__JBL_ERROR_END: jbl_ecode_t = 86020;
pub type jbl_ecode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JBL_iterator {
    pub pnext: *mut ::std::os::raw::c_uchar,
    pub plimit: *mut ::std::os::raw::c_uchar,
    pub type_: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub current: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__JBL_iterator() {
    assert_eq!(
        ::std::mem::size_of::<_JBL_iterator>(),
        32usize,
        concat!("Size of: ", stringify!(_JBL_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<_JBL_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(_JBL_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_iterator>())).pnext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_iterator),
            "::",
            stringify!(pnext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_iterator>())).plimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_iterator),
            "::",
            stringify!(plimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_iterator>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_iterator),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_iterator>())).count as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_iterator),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_iterator>())).current as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_iterator),
            "::",
            stringify!(current)
        )
    );
}
pub type JBL_iterator = _JBL_iterator;
pub type jbl_print_flags_t = u8;
pub type jbn_visitor_cmd_t = u8;
pub const jbl_type_t_JBV_NONE: jbl_type_t = 0;
pub const jbl_type_t_JBV_NULL: jbl_type_t = 1;
pub const jbl_type_t_JBV_BOOL: jbl_type_t = 2;
pub const jbl_type_t_JBV_I64: jbl_type_t = 3;
pub const jbl_type_t_JBV_F64: jbl_type_t = 4;
pub const jbl_type_t_JBV_STR: jbl_type_t = 5;
pub const jbl_type_t_JBV_OBJECT: jbl_type_t = 6;
pub const jbl_type_t_JBV_ARRAY: jbl_type_t = 7;
pub type jbl_type_t = u32;
#[doc = " @brief JSON document as in-memory tree (DOM tree)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JBL_NODE {
    pub next: *mut _JBL_NODE,
    pub prev: *mut _JBL_NODE,
    #[doc = "< Optional parent"]
    pub parent: *mut _JBL_NODE,
    pub key: *const ::std::os::raw::c_char,
    pub klidx: ::std::os::raw::c_int,
    #[doc = "< Utility node flags"]
    pub flags: u32,
    pub child: *mut _JBL_NODE,
    pub vsize: ::std::os::raw::c_int,
    pub type_: jbl_type_t,
    pub __bindgen_anon_1: _JBL_NODE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _JBL_NODE__bindgen_ty_1 {
    pub vptr: *const ::std::os::raw::c_char,
    pub vbool: bool,
    pub vi64: i64,
    pub vf64: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__JBL_NODE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_JBL_NODE__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_JBL_NODE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_JBL_NODE__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_JBL_NODE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE__bindgen_ty_1>())).vptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE__bindgen_ty_1),
            "::",
            stringify!(vptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE__bindgen_ty_1>())).vbool as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE__bindgen_ty_1),
            "::",
            stringify!(vbool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE__bindgen_ty_1>())).vi64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE__bindgen_ty_1),
            "::",
            stringify!(vi64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE__bindgen_ty_1>())).vf64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE__bindgen_ty_1),
            "::",
            stringify!(vf64)
        )
    );
}
#[test]
fn bindgen_test_layout__JBL_NODE() {
    assert_eq!(
        ::std::mem::size_of::<_JBL_NODE>(),
        64usize,
        concat!("Size of: ", stringify!(_JBL_NODE))
    );
    assert_eq!(
        ::std::mem::align_of::<_JBL_NODE>(),
        8usize,
        concat!("Alignment of ", stringify!(_JBL_NODE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE>())).parent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE>())).key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE>())).klidx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE),
            "::",
            stringify!(klidx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE>())).flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE>())).child as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE>())).vsize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE),
            "::",
            stringify!(vsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_NODE>())).type_ as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_NODE),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " @brief JSON document as in-memory tree (DOM tree)."]
pub type JBL_NODE = *mut _JBL_NODE;
pub const jbp_patch_t_JBP_ADD: jbp_patch_t = 1;
pub const jbp_patch_t_JBP_REMOVE: jbp_patch_t = 2;
pub const jbp_patch_t_JBP_REPLACE: jbp_patch_t = 3;
pub const jbp_patch_t_JBP_COPY: jbp_patch_t = 4;
pub const jbp_patch_t_JBP_MOVE: jbp_patch_t = 5;
pub const jbp_patch_t_JBP_TEST: jbp_patch_t = 6;
#[doc = "< Value increment"]
pub const jbp_patch_t_JBP_INCREMENT: jbp_patch_t = 7;
#[doc = "< Create intermediate object nodes for missing path segments"]
pub const jbp_patch_t_JBP_ADD_CREATE: jbp_patch_t = 8;
#[doc = "< Swap values of two nodes"]
pub const jbp_patch_t_JBP_SWAP: jbp_patch_t = 9;
#[doc = " @brief JSON Patch operation according to rfc6902"]
pub type jbp_patch_t = u32;
#[doc = " @brief JSON patch specification"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JBL_PATCH {
    pub op: jbp_patch_t,
    pub path: *const ::std::os::raw::c_char,
    pub from: *const ::std::os::raw::c_char,
    pub vjson: *const ::std::os::raw::c_char,
    pub vnode: JBL_NODE,
}
#[test]
fn bindgen_test_layout__JBL_PATCH() {
    assert_eq!(
        ::std::mem::size_of::<_JBL_PATCH>(),
        40usize,
        concat!("Size of: ", stringify!(_JBL_PATCH))
    );
    assert_eq!(
        ::std::mem::align_of::<_JBL_PATCH>(),
        8usize,
        concat!("Alignment of ", stringify!(_JBL_PATCH))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_PATCH>())).op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_PATCH),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_PATCH>())).path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_PATCH),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_PATCH>())).from as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_PATCH),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_PATCH>())).vjson as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_PATCH),
            "::",
            stringify!(vjson)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_PATCH>())).vnode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_PATCH),
            "::",
            stringify!(vnode)
        )
    );
}
#[doc = " @brief JSON patch specification"]
pub type JBL_PATCH = _JBL_PATCH;
#[doc = " @brief JSON pointer rfc6901"]
#[doc = " @see jbl_ptr_alloc()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JBL_PTR {
    #[doc = "< Opaque data associated with pointer"]
    pub op: u64,
    #[doc = "< Number of nodes"]
    pub cnt: ::std::os::raw::c_int,
    #[doc = "< Size of JBL_PTR allocated area"]
    pub sz: ::std::os::raw::c_int,
    #[doc = "< Path nodes"]
    pub n: [*mut ::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout__JBL_PTR() {
    assert_eq!(
        ::std::mem::size_of::<_JBL_PTR>(),
        24usize,
        concat!("Size of: ", stringify!(_JBL_PTR))
    );
    assert_eq!(
        ::std::mem::align_of::<_JBL_PTR>(),
        8usize,
        concat!("Alignment of ", stringify!(_JBL_PTR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_PTR>())).op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_PTR),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_PTR>())).cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_PTR),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_PTR>())).sz as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_PTR),
            "::",
            stringify!(sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBL_PTR>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBL_PTR),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " @brief JSON pointer rfc6901"]
#[doc = " @see jbl_ptr_alloc()"]
pub type JBL_PTR = *mut _JBL_PTR;
#[doc = " Prints JSON to some oputput specified by `op`"]
pub type jbl_json_printer = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        ch: ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        op: *mut ::std::os::raw::c_void,
    ) -> iwrc,
>;
extern "C" {
    #[doc = " @brief Create empty binary JSON object."]
    #[doc = ""]
    #[doc = " @note `jblp` should be disposed by `jbl_destroy()`"]
    #[doc = " @see `jbl_fill_from_node()`"]
    #[doc = " @param [out] jblp Pointer to be initialized by new object."]
    pub fn jbl_create_empty_object(jblp: *mut JBL) -> iwrc;
}
extern "C" {
    #[doc = " @brief Create empty binary JSON array."]
    #[doc = ""]
    #[doc = " @note `jblp` should be disposed by `jbl_destroy()`"]
    #[doc = " @see `jbl_fill_from_node()`"]
    #[doc = " @param [out] jblp Pointer to be initialized by new object."]
    pub fn jbl_create_empty_array(jblp: *mut JBL) -> iwrc;
}
extern "C" {
    #[doc = " @brief Sets arbitrary user data associated with JBL object."]
    #[doc = ""]
    #[doc = " @param jbl JBL container"]
    #[doc = " @param user_data User data pointer. Optional."]
    #[doc = " @param user_data_free_fn User data dispose function. Optional."]
    pub fn jbl_set_user_data(
        jbl: JBL,
        user_data: *mut ::std::os::raw::c_void,
        user_data_free_fn: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Returns user data associated with given `jbl` container."]
    #[doc = ""]
    #[doc = " @param jbl JBL container."]
    pub fn jbl_get_user_data(jbl: JBL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Set integer JBL object property value"]
    #[doc = "        or add a new entry to end of array JBL object."]
    #[doc = ""]
    #[doc = " In the case when `jbl` object is array value will be added to end array."]
    #[doc = ""]
    #[doc = " @warning `jbl` object must writable in other words created with"]
    #[doc = "          `jbl_create_empty_object()` or `jbl_create_empty_array()`"]
    #[doc = ""]
    #[doc = " @param jbl JBL container"]
    #[doc = " @param key Object key. Does't makes sense for array objects."]
    #[doc = " @param v   Value to set"]
    pub fn jbl_set_int64(jbl: JBL, key: *const ::std::os::raw::c_char, v: i64) -> iwrc;
}
extern "C" {
    #[doc = " @brief Set double JBL object property value"]
    #[doc = "        or add a new entry to end of array JBL object."]
    #[doc = ""]
    #[doc = " In the case when `jbl` object is array value will be added to end array."]
    #[doc = ""]
    #[doc = " @warning `jbl` object must writable in other words created with"]
    #[doc = "          `jbl_create_empty_object()` or `jbl_create_empty_array()`"]
    #[doc = ""]
    #[doc = " @param jbl JBL container"]
    #[doc = " @param key Object key. Does't makes sense for array objects."]
    #[doc = " @param v   Value to set"]
    pub fn jbl_set_f64(jbl: JBL, key: *const ::std::os::raw::c_char, v: f64) -> iwrc;
}
extern "C" {
    #[doc = " @brief Set string JBL object property value"]
    #[doc = "        or add a new entry to end of array JBL object."]
    #[doc = ""]
    #[doc = " In the case when `jbl` object is array value will be added to end array."]
    #[doc = ""]
    #[doc = " @warning `jbl` object must writable in other words created with"]
    #[doc = "          `jbl_create_empty_object()` or `jbl_create_empty_array()`"]
    #[doc = ""]
    #[doc = " @param jbl JBL container"]
    #[doc = " @param key Object key. Does't makes sense for array objects."]
    #[doc = " @param v   Value to set"]
    pub fn jbl_set_string(
        jbl: JBL,
        key: *const ::std::os::raw::c_char,
        v: *const ::std::os::raw::c_char,
    ) -> iwrc;
}
extern "C" {
    pub fn jbl_set_string_printf(
        jbl: JBL,
        key: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Set bool JBL object property value"]
    #[doc = "        or add a new entry to end of array JBL object."]
    #[doc = ""]
    #[doc = " In the case when `jbl` object is array value will be added to end array."]
    #[doc = ""]
    #[doc = " @warning `jbl` object must writable in other words created with"]
    #[doc = "          `jbl_create_empty_object()` or `jbl_create_empty_array()`"]
    #[doc = ""]
    #[doc = " @param jbl JBL container"]
    #[doc = " @param key Object key. Does't makes sense for array objects."]
    #[doc = " @param v   Value to set"]
    pub fn jbl_set_bool(jbl: JBL, key: *const ::std::os::raw::c_char, v: bool) -> iwrc;
}
extern "C" {
    #[doc = " @brief Set null JBL object property value"]
    #[doc = "        or add a new entry to end of array JBL object."]
    #[doc = ""]
    #[doc = " In the case when `jbl` object is array value will be added to end array."]
    #[doc = ""]
    #[doc = " @warning `jbl` object must writable in other words created with"]
    #[doc = "          `jbl_create_empty_object()` or `jbl_create_empty_array()`"]
    #[doc = ""]
    #[doc = " @param jbl JBL container"]
    #[doc = " @param key Object key. Does't makes sense for array objects."]
    #[doc = " @param v   Value to set"]
    pub fn jbl_set_null(jbl: JBL, key: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    pub fn jbl_set_empty_array(jbl: JBL, key: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    pub fn jbl_set_empty_object(jbl: JBL, key: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    #[doc = " @brief Set nested JBL object property value"]
    #[doc = "        or add a new entry to end of array JBL object."]
    #[doc = ""]
    #[doc = " In the case when `jbl` object is array value will be added to end array."]
    #[doc = ""]
    #[doc = " @warning `jbl` object must writable in other words created with"]
    #[doc = "          `jbl_create_empty_object()` or `jbl_create_empty_array()`"]
    #[doc = ""]
    #[doc = " @param jbl JBL container"]
    #[doc = " @param key Object key. Does't makes sense for array objects."]
    #[doc = " @param v   Value to set"]
    pub fn jbl_set_nested(jbl: JBL, key: *const ::std::os::raw::c_char, nested: JBL) -> iwrc;
}
extern "C" {
    #[doc = " @brief Initialize new `JBL` document by `binn` data from buffer."]
    #[doc = " @note Created document will be allocated by `malloc()`"]
    #[doc = " and should be destroyed by `jbl_destroy()`."]
    #[doc = ""]
    #[doc = " @param [out] jblp        Pointer initialized by created JBL document. Not zero."]
    #[doc = " @param buf               Memory buffer with `binn` data. Not zero."]
    #[doc = " @param bufsz             Size of `buf`"]
    #[doc = " @param keep_on_destroy   If true `buf` not will be freed by `jbl_destroy()`"]
    pub fn jbl_from_buf_keep(
        jblp: *mut JBL,
        buf: *mut ::std::os::raw::c_void,
        bufsz: usize,
        keep_on_destroy: bool,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Clones the given `src` JBL object into newly allocated `targetp` object."]
    #[doc = ""]
    #[doc = " JBL object stored into `targetp` should be disposed by `jbl_destroy()`."]
    #[doc = ""]
    #[doc = " @param src Source object to clone"]
    #[doc = " @param targetp Pointer on target object."]
    pub fn jbl_clone(src: JBL, targetp: *mut JBL) -> iwrc;
}
extern "C" {
    #[doc = " @brief Copy all keys from `src` object into `target` object."]
    #[doc = " @note Function does not care about keys duplication."]
    #[doc = ""]
    #[doc = " @param src Source JBL object. Must be object."]
    #[doc = " @param target Target JBL object. Must be object."]
    pub fn jbl_object_copy_to(src: JBL, target: JBL) -> iwrc;
}
extern "C" {
    #[doc = " @brief Clones the given `src` JBL_NODE object into new `targetp` instance."]
    #[doc = "        Memory allocateted by given memor `pool` instance."]
    #[doc = ""]
    #[doc = " @param src Source object to clone"]
    #[doc = " @param target Pointer on new instance"]
    #[doc = " @param pool Memory pool used for allocations during clone object construction"]
    pub fn jbn_clone(src: JBL_NODE, targetp: *mut JBL_NODE, pool: *mut IWPOOL) -> iwrc;
}
extern "C" {
    #[doc = " @brief Assign a JSON node value from `from` node into `target` node."]
    #[doc = "        Context elements of `target` node: `parent`, `next` are not touched."]
    #[doc = ""]
    #[doc = " @param target Node"]
    #[doc = " @param from"]
    #[doc = " @return IW_EXPORT jbn_apply_from"]
    pub fn jbn_apply_from(target: JBL_NODE, from: JBL_NODE);
}
extern "C" {
    #[doc = " @brief Copies JSON subtree under given `src_path` into `target` object under `target_path`."]
    #[doc = "        If some tree exists under `target_path` it will be replaced by copied subtree."]
    #[doc = ""]
    #[doc = " Copied subtree will be allocated in using given memory `pool`."]
    #[doc = ""]
    #[doc = " @param src Source JSON tree."]
    #[doc = " @param src_path Path where copied subtree located. If src_path is `/` then `src` object itself will be cloned."]
    #[doc = " @param target Target JSON tree."]
    #[doc = " @param target_path Path to place copied subtree."]
    #[doc = " @param overwrite_on_nulls If true `null` values will be copied to `src` object as well."]
    #[doc = " @param no_src_clone If true object pointed by `src_path` object will not be cloned into `pool` before applying patch."]
    #[doc = "                     It is a dangerous option if you use same memory pool for source and target objects."]
    #[doc = "                     Do not set it to `true` until you clearly understand what are you doing."]
    #[doc = " @param pool Memory pool used for allocations"]
    pub fn jbn_copy_path(
        src: JBL_NODE,
        src_path: *const ::std::os::raw::c_char,
        target: JBL_NODE,
        target_path: *const ::std::os::raw::c_char,
        overwrite_on_nulls: bool,
        no_src_clone: bool,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Copies a set of values pointed by `paths` zero terminated array"]
    #[doc = "        of `src` object into respective paths of `target` object."]
    #[doc = ""]
    #[doc = " @param src Source object whose keys will be copied."]
    #[doc = " @param target Target object to recieve key values of `src` obejct"]
    #[doc = " @param paths Zero terminated array of pointers to zero terminated key names."]
    #[doc = " @param overwrite_on_nulls If true `null` values will be copied to `src` object as well."]
    #[doc = " @param no_src_clone If true copied objects will not be cloned into given `pool` before copying."]
    #[doc = "                     It is a dangerous option if you use same memory pool for source and target objects."]
    #[doc = "                     Do not set it to `true` until you clearly understand what are you doing."]
    #[doc = " @param pool Memory pool used for allocations"]
    pub fn jbn_copy_paths(
        src: JBL_NODE,
        target: JBL_NODE,
        paths: *mut *const ::std::os::raw::c_char,
        overwrite_on_nulls: bool,
        no_src_clone: bool,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Clones a given `src` JBL object and stores it in memory allocated from `pool`."]
    #[doc = ""]
    #[doc = " @param src Source object to clone"]
    #[doc = " @param targetp Pointer on target object"]
    #[doc = " @param pool  Memory pool"]
    pub fn jbl_clone_into_pool(src: JBL, targetp: *mut JBL, pool: *mut IWPOOL) -> iwrc;
}
extern "C" {
    #[doc = " @brief Constructs new `JBL` object from JSON string."]
    #[doc = " @note `jblp` should be disposed by `jbl_destroy()`"]
    #[doc = " @param [out] jblp  Pointer initialized by created JBL document. Not zero."]
    #[doc = " @param jsonstr     JSON string to be converted"]
    pub fn jbl_from_json(jblp: *mut JBL, jsonstr: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    pub fn jbl_from_json_printf(jblp: *mut JBL, format: *const ::std::os::raw::c_char, ...)
        -> iwrc;
}
extern "C" {
    pub fn jbl_from_json_printf_va(
        jblp: *mut JBL,
        format: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get type of `jbl` value."]
    pub fn jbl_type(jbl: JBL) -> jbl_type_t;
}
extern "C" {
    #[doc = " @brief Get number of child elements in `jbl` container (object/array) or zero."]
    pub fn jbl_count(jbl: JBL) -> usize;
}
extern "C" {
    #[doc = " @brief Get size of undelying data buffer of `jbl` value passed."]
    pub fn jbl_size(jbl: JBL) -> usize;
}
extern "C" {
    #[doc = " @brief Returns size of JBL underlying data structure"]
    pub fn jbl_structure_size() -> usize;
}
extern "C" {
    pub fn jbl_from_buf_keep_onstack(
        jbl: JBL,
        buf: *mut ::std::os::raw::c_void,
        bufsz: usize,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Interpret `jbl` value as `int32_t`."]
    #[doc = " Returns zero if value cannot be converted."]
    pub fn jbl_get_i32(jbl: JBL) -> i32;
}
extern "C" {
    #[doc = " @brief Interpret `jbl` value as `int64_t`."]
    #[doc = " Returns zero if value cannot be converted."]
    pub fn jbl_get_i64(jbl: JBL) -> i64;
}
extern "C" {
    #[doc = " @brief Interpret `jbl` value as `double` value."]
    #[doc = " Returns zero if value cannot be converted."]
    pub fn jbl_get_f64(jbl: JBL) -> f64;
}
extern "C" {
    #[doc = " @brief Interpret `jbl` value as `\\0` terminated character array."]
    #[doc = " Returns zero if value cannot be converted."]
    pub fn jbl_get_str(jbl: JBL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jbl_object_get_i64(jbl: JBL, key: *const ::std::os::raw::c_char, out: *mut i64) -> iwrc;
}
extern "C" {
    pub fn jbl_object_get_f64(jbl: JBL, key: *const ::std::os::raw::c_char, out: *mut f64) -> iwrc;
}
extern "C" {
    pub fn jbl_object_get_bool(
        jbl: JBL,
        key: *const ::std::os::raw::c_char,
        out: *mut bool,
    ) -> iwrc;
}
extern "C" {
    pub fn jbl_object_get_str(
        jbl: JBL,
        key: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
    ) -> iwrc;
}
extern "C" {
    pub fn jbl_object_get_fill_jbl(jbl: JBL, key: *const ::std::os::raw::c_char, out: JBL) -> iwrc;
}
extern "C" {
    pub fn jbl_object_get_type(jbl: JBL, key: *const ::std::os::raw::c_char) -> jbl_type_t;
}
extern "C" {
    #[doc = " @brief Same as `jbl_get_str()` but copies at most `bufsz` into target `buf`."]
    #[doc = " Target buffer not touched if `jbl` value cannot be converted."]
    pub fn jbl_copy_strn(jbl: JBL, buf: *mut ::std::os::raw::c_char, bufsz: usize) -> usize;
}
extern "C" {
    #[doc = " @brief Finds value in `jbl` document pointed by rfc6901 `path` and store it into `res`."]
    #[doc = ""]
    #[doc = " @note `res` should be disposed by `jbl_destroy()`."]
    #[doc = " @note If value is not fount `res` will be set to zero."]
    #[doc = " @param jbl         JBL document. Not zero."]
    #[doc = " @param path        rfc6901 JSON pointer. Not zero."]
    #[doc = " @param [out] res   Output value holder"]
    pub fn jbl_at(jbl: JBL, path: *const ::std::os::raw::c_char, res: *mut JBL) -> iwrc;
}
extern "C" {
    pub fn jbn_at(node: JBL_NODE, path: *const ::std::os::raw::c_char, res: *mut JBL_NODE) -> iwrc;
}
extern "C" {
    pub fn jbn_path_compare(
        n1: JBL_NODE,
        n2: JBL_NODE,
        path: *const ::std::os::raw::c_char,
        vtype: jbl_type_t,
        rcp: *mut iwrc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jbn_paths_compare(
        n1: JBL_NODE,
        n1path: *const ::std::os::raw::c_char,
        n2: JBL_NODE,
        n2path: *const ::std::os::raw::c_char,
        vtype: jbl_type_t,
        rcp: *mut iwrc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jbn_path_compare_str(
        n: JBL_NODE,
        path: *const ::std::os::raw::c_char,
        sv: *const ::std::os::raw::c_char,
        rcp: *mut iwrc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jbn_path_compare_i64(
        n: JBL_NODE,
        path: *const ::std::os::raw::c_char,
        iv: i64,
        rcp: *mut iwrc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jbn_path_compare_f64(
        n: JBL_NODE,
        path: *const ::std::os::raw::c_char,
        fv: f64,
        rcp: *mut iwrc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jbn_path_compare_bool(
        n: JBL_NODE,
        path: *const ::std::os::raw::c_char,
        bv: bool,
        rcp: *mut iwrc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief @brief Finds value in `jbl` document pointed by `jp` structure and store it into `res`."]
    #[doc = ""]
    #[doc = " @note `res` should be disposed by `jbl_destroy()`."]
    #[doc = " @note If value is not fount `res` will be set to zero."]
    #[doc = " @see `jbl_ptr_alloc()`"]
    #[doc = " @param jbl         JBL document. Not zero."]
    #[doc = " @param jp          JSON pointer."]
    #[doc = " @param [out] res   Output value holder"]
    pub fn jbl_at2(jbl: JBL, jp: JBL_PTR, res: *mut JBL) -> iwrc;
}
extern "C" {
    pub fn jbn_at2(node: JBL_NODE, jp: JBL_PTR, res: *mut JBL_NODE) -> iwrc;
}
extern "C" {
    #[doc = " @brief Represent `jbl` document as raw data buffer."]
    #[doc = ""]
    #[doc = " @note Caller do not require release `buf` explicitly."]
    #[doc = " @param jbl         JBL document. Not zero."]
    #[doc = " @param [out] buf   Pointer to data buffer. Not zero."]
    #[doc = " @param [out] size  Pointer to data buffer size. Not zero."]
    pub fn jbl_as_buf(jbl: JBL, buf: *mut *mut ::std::os::raw::c_void, size: *mut usize) -> iwrc;
}
extern "C" {
    #[doc = " @brief Prints JBL document as JSON string."]
    #[doc = ""]
    #[doc = " @see jbl_fstream_json_printer()"]
    #[doc = " @see jbl_xstr_json_printer()"]
    #[doc = " @see jbl_count_json_printer()"]
    #[doc = ""]
    #[doc = " @param jbl  JBL document. Not zero."]
    #[doc = " @param pt   JSON printer function pointer. Not zero."]
    #[doc = " @param op   Pointer to user data for JSON printer function."]
    #[doc = " @param pf   JSON printing mode."]
    pub fn jbl_as_json(
        jbl: JBL,
        pt: jbl_json_printer,
        op: *mut ::std::os::raw::c_void,
        pf: jbl_print_flags_t,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief JSON printer to stdlib `FILE*`pointer. Eg: `stderr`, `stdout`"]
    #[doc = " @param op `FILE*` pointer"]
    pub fn jbl_fstream_json_printer(
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        ch: ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        op: *mut ::std::os::raw::c_void,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief JSON printer to extended string buffer `IWXSTR`"]
    #[doc = " @param op `IWXSTR*` pointer"]
    pub fn jbl_xstr_json_printer(
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        ch: ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        op: *mut ::std::os::raw::c_void,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Just counts bytes in JSON text."]
    #[doc = " @param op `int*` Pointer to counter number."]
    pub fn jbl_count_json_printer(
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        ch: ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        op: *mut ::std::os::raw::c_void,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Destroys JBL document and releases its heap resources."]
    #[doc = " @note Will set `jblp` to zero."]
    #[doc = " @param jblp Pointer holder of JBL document. Not zero."]
    pub fn jbl_destroy(jblp: *mut JBL);
}
extern "C" {
    #[doc = " @brief Initializes placeholder for jbl iteration."]
    #[doc = "        Must be freed by `jbl_destroy()` after iteration."]
    #[doc = " @param [out] jblp Pointer to be initialized by new object."]
    pub fn jbl_create_iterator_holder(jblp: *mut JBL) -> iwrc;
}
extern "C" {
    #[doc = " @brief Initialize allocated iterator over given `jbl` object."]
    #[doc = ""]
    #[doc = " @param jbl JBL object to iterate"]
    #[doc = " @param iter Iterator state placeholder allocated by `jbl_create_iter_placeholder()`"]
    pub fn jbl_iterator_init(jbl: JBL, iter: *mut JBL_iterator) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get next value from JBL_iterator."]
    #[doc = " Returns `false` if iteration is over."]
    #[doc = ""]
    #[doc = " @param iter    Iterator object."]
    #[doc = " @param holder  Holder to object pointed by current iteration."]
    #[doc = " @param pkey    Key value holder. Zero in the case of iteration over array."]
    #[doc = " @param klen    Key length or array index in the case of iteration over array."]
    pub fn jbl_iterator_next(
        iter: *mut JBL_iterator,
        holder: JBL,
        pkey: *mut *mut ::std::os::raw::c_char,
        klen: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Converts `jbl` value to `JBL_NODE` tree."]
    #[doc = " @note `node` resources will be released when `pool` destroyed."]
    #[doc = ""]
    #[doc = " @param jbl             JSON document in compact `binn` format. Not zero."]
    #[doc = " @param [out] node      Holder of new `JBL_NODE` value. Not zero."]
    #[doc = " @param clone_strings   If `true` JSON keys and string values will be cloned into given `pool`"]
    #[doc = "                        otherwise only pointers to strings will be assigned."]
    #[doc = "                        Use `true` if you want to be completely safe when given `jbl`"]
    #[doc = "                        object will be destroyed."]
    #[doc = " @param pool            Memory used to allocate new `JBL_NODE` tree. Not zero."]
    pub fn jbl_to_node(
        jbl: JBL,
        node: *mut JBL_NODE,
        clone_strings: bool,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Converts `json` text to `JBL_NODE` tree."]
    #[doc = " @note `node` resources will be released when `pool` destroyed."]
    #[doc = ""]
    #[doc = " @param json        JSON text"]
    #[doc = " @param [out] node  Holder of new `JBL_NODE` value. Not zero."]
    #[doc = " @param pool        Memory used to allocate new `JBL_NODE` tree. Not zero."]
    pub fn jbn_from_json(
        json: *const ::std::os::raw::c_char,
        node: *mut JBL_NODE,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    pub fn jbn_from_json_printf(
        node: *mut JBL_NODE,
        pool: *mut IWPOOL,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> iwrc;
}
extern "C" {
    pub fn jbn_from_json_printf_va(
        node: *mut JBL_NODE,
        pool: *mut IWPOOL,
        format: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Prints JBL_NODE document as JSON string."]
    #[doc = ""]
    #[doc = " @see jbl_fstream_json_printer()"]
    #[doc = " @see jbl_xstr_json_printer()"]
    #[doc = " @see jbl_count_json_printer()"]
    #[doc = ""]
    #[doc = " @param node `JBL_NODE` document. Not zero."]
    #[doc = " @param pt    JSON printer function. Not zero."]
    #[doc = " @param op    Pointer to user data for JSON printer function."]
    #[doc = " @param pf    JSON printing mode."]
    pub fn jbn_as_json(
        node: JBL_NODE,
        pt: jbl_json_printer,
        op: *mut ::std::os::raw::c_void,
        pf: jbl_print_flags_t,
    ) -> iwrc;
}
extern "C" {
    pub fn jbl_node_as_json(
        node: JBL_NODE,
        pt: jbl_json_printer,
        op: *mut ::std::os::raw::c_void,
        pf: jbl_print_flags_t,
    ) -> iwrc;
}
extern "C" {
    pub fn jbl_node_from_json(
        json: *const ::std::os::raw::c_char,
        node: *mut JBL_NODE,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Fill `jbl` document by data from `node`."]
    #[doc = ""]
    #[doc = " Common use case:"]
    #[doc = "  Create empty document with `jbl_create_empty_object()` `jbl_create_empty_array()`"]
    #[doc = "  then fill it with `jbl_fill_from_node()`"]
    #[doc = ""]
    #[doc = " @param jbl   JBL document to be filled. Not zero."]
    #[doc = " @param node  Source tree node. Not zero."]
    pub fn jbl_fill_from_node(jbl: JBL, node: JBL_NODE) -> iwrc;
}
extern "C" {
    #[doc = " @brief Converts `node` object into JBL form."]
    #[doc = ""]
    #[doc = " @param jblp  JBL pointer holder. Not zero."]
    #[doc = " @param node  Source tree node. Not zero."]
    #[doc = " @return IW_EXPORT jbl_from_node"]
    pub fn jbl_from_node(jblp: *mut JBL, node: JBL_NODE) -> iwrc;
}
extern "C" {
    #[doc = " @brief Compares JSON tree nodes."]
    #[doc = ""]
    #[doc = " - Primitive JSON values compared as is."]
    #[doc = " - JSON arrays compared by values held in the same position in array."]
    #[doc = " - JSON objects compared by corresponding values held under lexicographically sorted keys."]
    #[doc = ""]
    #[doc = " @param n1"]
    #[doc = " @param n2"]
    #[doc = " @param [out] rcp"]
    #[doc = ""]
    #[doc = " @return - Not zero if `n1` and `n2` have different types."]
    #[doc = "         - Zero if `n1` and `n2` are equal."]
    #[doc = "         - Greater than zero  if `n1` greater than `n2`"]
    #[doc = "         - Lesser than zero if `n1` lesser than `n2`"]
    pub fn jbn_compare_nodes(n1: JBL_NODE, n2: JBL_NODE, rcp: *mut iwrc) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add item to the `parent` container."]
    pub fn jbn_add_item(parent: JBL_NODE, node: JBL_NODE);
}
extern "C" {
    #[doc = " @brief Adds string JSON node to the given `parent` node."]
    #[doc = "        Key and value are copied into allocated node."]
    #[doc = ""]
    #[doc = " @param parent Parent holder."]
    #[doc = " @param key Child node key cloned into node. Can be zero if parent is an array."]
    #[doc = " @param val Child node value copied."]
    #[doc = " @param vlen Langth of child node value."]
    #[doc = "             If `vlen` is lesser then zero length of `val` will be determined my `strlen`."]
    #[doc = " @param node_out Optional placeholder for new node."]
    #[doc = " @param pool Allocation pool."]
    pub fn jbn_add_item_str(
        parent: JBL_NODE,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        vlen: ::std::os::raw::c_int,
        node_out: *mut JBL_NODE,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Adds null JSON value to the given `parent` node."]
    #[doc = ""]
    #[doc = " @param parent Parent holder."]
    #[doc = " @param key Child node key cloned into node. Can be zero if parent is an array."]
    #[doc = " @param pool Allocation pool."]
    pub fn jbn_add_item_null(
        parent: JBL_NODE,
        key: *const ::std::os::raw::c_char,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Adds integer JSON node to the given `parent` node."]
    #[doc = ""]
    #[doc = " @param parent Parent holder."]
    #[doc = " @param key Child node key cloned into node. Can be zero if parent is an array."]
    #[doc = " @param val Integer value."]
    #[doc = " @param node_out Optional placeholder for new node."]
    #[doc = " @param pool Allocation pool."]
    pub fn jbn_add_item_i64(
        parent: JBL_NODE,
        key: *const ::std::os::raw::c_char,
        val: i64,
        node_out: *mut JBL_NODE,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Adds fp number JSON node to the given `parent` node."]
    #[doc = ""]
    #[doc = " @param parent Parent holder."]
    #[doc = " @param key Child node key cloned into node. Can be zero if parent is an array."]
    #[doc = " @param val Floating point value."]
    #[doc = " @param node_out Optional placeholder for new node."]
    #[doc = " @param pool Allocation pool."]
    pub fn jbn_add_item_f64(
        parent: JBL_NODE,
        key: *const ::std::os::raw::c_char,
        val: f64,
        node_out: *mut JBL_NODE,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Add nested object under the given `key`"]
    #[doc = ""]
    #[doc = " @param parent Parent holder"]
    #[doc = " @param key Child node key cloned into node. Can be zero if parent is an array."]
    #[doc = " @param node_out [out] Pointer to new node, can be zero."]
    #[doc = " @param pool Allocation pool"]
    #[doc = " @return IW_EXPORT jbn_add_item_obj"]
    pub fn jbn_add_item_obj(
        parent: JBL_NODE,
        key: *const ::std::os::raw::c_char,
        node_out: *mut JBL_NODE,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Add nested array under the given `key`"]
    #[doc = ""]
    #[doc = " @param parent Parent holder"]
    #[doc = " @param key Child node key cloned into node. Can be zero if parent is an array."]
    #[doc = " @param node_out [out] Pointer to new node, can be zero."]
    #[doc = " @param pool Allocation pool"]
    #[doc = " @return IW_EXPORT jbn_add_item_obj"]
    pub fn jbn_add_item_arr(
        parent: JBL_NODE,
        key: *const ::std::os::raw::c_char,
        node_out: *mut JBL_NODE,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Adds boolean JSON node to the given `parent` node."]
    #[doc = ""]
    #[doc = " @param parent Parent holder."]
    #[doc = " @param key Child node key cloned into node. Can be zero if parent is an array."]
    #[doc = " @param val Boolean node value."]
    #[doc = " @param node_out [out] Pointer to new node, can be zero."]
    #[doc = " @param pool Allocation pool."]
    pub fn jbn_add_item_bool(
        parent: JBL_NODE,
        key: *const ::std::os::raw::c_char,
        val: bool,
        node_out: *mut JBL_NODE,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Add item from the `parent` container."]
    pub fn jbn_remove_item(parent: JBL_NODE, child: JBL_NODE);
}
extern "C" {
    #[doc = " @brief Remove subtree from `target` node pointed by `path`"]
    pub fn jbn_detach2(target: JBL_NODE, path: JBL_PTR) -> JBL_NODE;
}
extern "C" {
    pub fn jbn_detach(target: JBL_NODE, path: *const ::std::os::raw::c_char) -> JBL_NODE;
}
extern "C" {
    #[doc = " @brief Reset tree `node` data."]
    pub fn jbn_data(node: JBL_NODE);
}
extern "C" {
    #[doc = " @brief Returns number of child elements of given node."]
    #[doc = ""]
    #[doc = " @param node JBL node"]
    pub fn jbn_length(node: JBL_NODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Parses rfc6901 JSON path."]
    #[doc = " @note `jpp` structure should be disposed by `free()`."]
    #[doc = ""]
    #[doc = " @param path      JSON path string. Not zero."]
    #[doc = " @param [out] jpp Holder for parsed path structure. Not zero."]
    pub fn jbl_ptr_alloc(path: *const ::std::os::raw::c_char, jpp: *mut JBL_PTR) -> iwrc;
}
extern "C" {
    #[doc = " @brief Parses rfc6901 JSON path."]
    #[doc = ""]
    #[doc = " @param path  JSON path string. Not zero."]
    #[doc = " @param [out] jpp JSON path string. Not zero."]
    #[doc = " @param pool  Pool used for memory allocation. Not zero."]
    pub fn jbl_ptr_alloc_pool(
        path: *const ::std::os::raw::c_char,
        jpp: *mut JBL_PTR,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Compare JSON pointers."]
    pub fn jbl_ptr_cmp(p1: JBL_PTR, p2: JBL_PTR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Serialize JSON pointer to as text."]
    #[doc = " @param ptr   JSON pointer. Not zero."]
    #[doc = " @param xstr  Output string buffer. Not zero."]
    pub fn jbl_ptr_serialize(ptr: JBL_PTR, xstr: *mut IWXSTR) -> iwrc;
}
#[doc = " @brief JBL_NODE visitor context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JBN_VCTX {
    #[doc = "< Root node from which started visitor"]
    pub root: JBL_NODE,
    #[doc = "< Arbitrary opaque data"]
    pub op: *mut ::std::os::raw::c_void,
    pub result: *mut ::std::os::raw::c_void,
    #[doc = "< Pool placeholder, initialization is responsibility of `JBN_VCTX` creator"]
    pub pool: *mut IWPOOL,
    #[doc = "< Aux position, not actually used by visitor core"]
    pub pos: ::std::os::raw::c_int,
    #[doc = "< It `true` document traversal will be terminated immediately."]
    pub terminate: bool,
}
#[test]
fn bindgen_test_layout__JBN_VCTX() {
    assert_eq!(
        ::std::mem::size_of::<_JBN_VCTX>(),
        40usize,
        concat!("Size of: ", stringify!(_JBN_VCTX))
    );
    assert_eq!(
        ::std::mem::align_of::<_JBN_VCTX>(),
        8usize,
        concat!("Alignment of ", stringify!(_JBN_VCTX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBN_VCTX>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBN_VCTX),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBN_VCTX>())).op as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBN_VCTX),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBN_VCTX>())).result as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBN_VCTX),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBN_VCTX>())).pool as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBN_VCTX),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBN_VCTX>())).pos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBN_VCTX),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JBN_VCTX>())).terminate as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_JBN_VCTX),
            "::",
            stringify!(terminate)
        )
    );
}
#[doc = " @brief JBL_NODE visitor context"]
pub type JBN_VCTX = _JBN_VCTX;
#[doc = " Call with lvl: `-1` means end of visiting whole object tree."]
pub type JBN_VISITOR = ::std::option::Option<
    unsafe extern "C" fn(
        lvl: ::std::os::raw::c_int,
        n: JBL_NODE,
        key: *const ::std::os::raw::c_char,
        klidx: ::std::os::raw::c_int,
        vctx: *mut JBN_VCTX,
        rc: *mut iwrc,
    ) -> jbn_visitor_cmd_t,
>;
extern "C" {
    pub fn jbn_visit(
        node: JBL_NODE,
        lvl: ::std::os::raw::c_int,
        vctx: *mut JBN_VCTX,
        visitor: JBN_VISITOR,
    ) -> iwrc;
}
extern "C" {
    pub fn jbn_patch_auto(root: JBL_NODE, patch: JBL_NODE, pool: *mut IWPOOL) -> iwrc;
}
extern "C" {
    pub fn jbn_merge_patch(root: JBL_NODE, patch: JBL_NODE, pool: *mut IWPOOL) -> iwrc;
}
extern "C" {
    pub fn jbn_patch(
        root: JBL_NODE,
        patch: *const JBL_PATCH,
        cnt: usize,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    pub fn jbn_merge_patch_from_json(
        root: JBL_NODE,
        patchjson: *const ::std::os::raw::c_char,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    pub fn jbl_patch(jbl: JBL, patch: *const JBL_PATCH, cnt: usize) -> iwrc;
}
extern "C" {
    pub fn jbl_patch_from_json(jbl: JBL, patchjson: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    pub fn jbl_merge_patch(jbl: JBL, patchjson: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    pub fn jbl_merge_patch_jbl(jbl: JBL, patch: JBL) -> iwrc;
}
extern "C" {
    pub fn jbl_init() -> iwrc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JQL {
    _unused: [u8; 0],
}
pub type JQL = *mut _JQL;
pub const jql_ecode_t__JQL_ERROR_START: jql_ecode_t = 87000;
#[doc = "< Query parsing error (JQL_ERROR_QUERY_PARSE)"]
pub const jql_ecode_t_JQL_ERROR_QUERY_PARSE: jql_ecode_t = 87001;
#[doc = "< Invalid placeholder position (JQL_ERROR_INVALID_PLACEHOLDER)"]
pub const jql_ecode_t_JQL_ERROR_INVALID_PLACEHOLDER: jql_ecode_t = 87002;
#[doc = "< Found unset placeholder (JQL_ERROR_UNSET_PLACEHOLDER)"]
pub const jql_ecode_t_JQL_ERROR_UNSET_PLACEHOLDER: jql_ecode_t = 87003;
#[doc = "< Invalid regular expression (JQL_ERROR_REGEXP_INVALID)"]
pub const jql_ecode_t_JQL_ERROR_REGEXP_INVALID: jql_ecode_t = 87004;
pub const jql_ecode_t_JQL_ERROR_REGEXP_CHARSET: jql_ecode_t = 87005;
pub const jql_ecode_t_JQL_ERROR_REGEXP_SUBEXP: jql_ecode_t = 87006;
pub const jql_ecode_t_JQL_ERROR_REGEXP_SUBMATCH: jql_ecode_t = 87007;
pub const jql_ecode_t_JQL_ERROR_REGEXP_ENGINE: jql_ecode_t = 87008;
#[doc = "< Skip clause already specified (JQL_ERROR_SKIP_ALREADY_SET)"]
pub const jql_ecode_t_JQL_ERROR_SKIP_ALREADY_SET: jql_ecode_t = 87009;
#[doc = "< Limit clause already specified (JQL_ERROR_SKIP_ALREADY_SET)"]
pub const jql_ecode_t_JQL_ERROR_LIMIT_ALREADY_SET: jql_ecode_t = 87010;
pub const jql_ecode_t_JQL_ERROR_ORDERBY_MAX_LIMIT: jql_ecode_t = 87011;
#[doc = "< No collection specified in query (JQL_ERROR_NO_COLLECTION)"]
pub const jql_ecode_t_JQL_ERROR_NO_COLLECTION: jql_ecode_t = 87012;
pub const jql_ecode_t_JQL_ERROR_INVALID_PLACEHOLDER_VALUE_TYPE: jql_ecode_t = 87013;
pub const jql_ecode_t__JQL_ERROR_END: jql_ecode_t = 87014;
pub const jql_ecode_t__JQL_ERROR_UNMATCHED: jql_ecode_t = 87015;
pub type jql_ecode_t = u32;
pub type jql_create_mode_t = u8;
extern "C" {
    #[doc = " @brief Create query object from specified text query."]
    #[doc = " @param qptr Pointer to resulting query object"]
    #[doc = " @param coll Optional collection name used to execute query"]
    #[doc = " @param query Query text"]
    pub fn jql_create(
        qptr: *mut JQL,
        coll: *const ::std::os::raw::c_char,
        query: *const ::std::os::raw::c_char,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_create2(
        qptr: *mut JQL,
        coll: *const ::std::os::raw::c_char,
        query: *const ::std::os::raw::c_char,
        mode: jql_create_mode_t,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_collection(q: JQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Bind JSON node data to query placeholder."]
    #[doc = " @warning Value JSON data is not copied and used as is."]
    #[doc = "          Caller is responsible to maintain `val` availability during execution of query."]
    #[doc = " @see jql_set_json2()"]
    pub fn jql_set_json(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        val: JBL_NODE,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_set_json2(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        val: JBL_NODE,
        freefn: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        op: *mut ::std::os::raw::c_void,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_set_json_jbl(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        jbl: JBL,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_set_i64(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        val: i64,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_set_f64(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        val: f64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Bind string data to query placeholder."]
    #[doc = " @warning Value string data is not copied and used as is."]
    #[doc = "          Caller is responsible to maintain `val` availability during execution of query."]
    #[doc = " @see jql_set_str2()"]
    pub fn jql_set_str(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        val: *const ::std::os::raw::c_char,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_set_str2(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        val: *const ::std::os::raw::c_char,
        freefn: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        op: *mut ::std::os::raw::c_void,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_set_bool(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        val: bool,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Bind regexp data string to query placeholder."]
    #[doc = " @warning Value string data is not copied and used as is."]
    #[doc = "          Caller is responsible to maintain `val` availability during execution of query."]
    #[doc = " @see jql_set_regexp2()"]
    pub fn jql_set_regexp(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        expr: *const ::std::os::raw::c_char,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_set_regexp2(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        expr: *const ::std::os::raw::c_char,
        freefn: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        op: *mut ::std::os::raw::c_void,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_set_null(
        q: JQL,
        placeholder: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_matched(q: JQL, jbl: JBL, out: *mut bool) -> iwrc;
}
extern "C" {
    pub fn jql_first_anchor(q: JQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jql_error(q: JQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jql_has_apply(q: JQL) -> bool;
}
extern "C" {
    pub fn jql_has_apply_upsert(q: JQL) -> bool;
}
extern "C" {
    pub fn jql_has_apply_delete(q: JQL) -> bool;
}
extern "C" {
    pub fn jql_has_projection(q: JQL) -> bool;
}
extern "C" {
    pub fn jql_has_orderby(q: JQL) -> bool;
}
extern "C" {
    pub fn jql_has_aggregate_count(q: JQL) -> bool;
}
extern "C" {
    pub fn jql_get_skip(q: JQL, out: *mut i64) -> iwrc;
}
extern "C" {
    pub fn jql_get_limit(q: JQL, out: *mut i64) -> iwrc;
}
extern "C" {
    pub fn jql_apply(q: JQL, root: JBL_NODE, pool: *mut IWPOOL) -> iwrc;
}
extern "C" {
    pub fn jql_project(
        q: JQL,
        root: JBL_NODE,
        pool: *mut IWPOOL,
        exec_ctx: *mut ::std::os::raw::c_void,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_apply_and_project(
        q: JQL,
        jbl: JBL,
        out: *mut JBL_NODE,
        exec_ctx: *mut ::std::os::raw::c_void,
        pool: *mut IWPOOL,
    ) -> iwrc;
}
extern "C" {
    pub fn jql_reset(q: JQL, reset_match_cache: bool, reset_placeholders: bool);
}
extern "C" {
    pub fn jql_destroy(qptr: *mut JQL);
}
extern "C" {
    pub fn jql_estimate_allocated_size(q: JQL) -> usize;
}
extern "C" {
    pub fn jql_init() -> iwrc;
}
extern "C" {
    #[doc = " @brief ejdb2 initialization routine."]
    #[doc = " @note Must be called before using any of ejdb API function."]
    pub fn ejdb_init() -> iwrc;
}
pub const ejdb_ecode_t__EJDB_ERROR_START: ejdb_ecode_t = 85000;
#[doc = "< Invalid collection name"]
pub const ejdb_ecode_t_EJDB_ERROR_INVALID_COLLECTION_NAME: ejdb_ecode_t = 85001;
#[doc = "< Invalid collection metadata"]
pub const ejdb_ecode_t_EJDB_ERROR_INVALID_COLLECTION_META: ejdb_ecode_t = 85002;
#[doc = "< Invalid collection index metadata"]
pub const ejdb_ecode_t_EJDB_ERROR_INVALID_COLLECTION_INDEX_META: ejdb_ecode_t = 85003;
#[doc = "< Invalid index mode specified"]
pub const ejdb_ecode_t_EJDB_ERROR_INVALID_INDEX_MODE: ejdb_ecode_t = 85004;
#[doc = "< Index exists but mismatched uniqueness constraint"]
pub const ejdb_ecode_t_EJDB_ERROR_MISMATCHED_INDEX_UNIQUENESS_MODE: ejdb_ecode_t = 85005;
#[doc = "< Unique index constraint violated"]
pub const ejdb_ecode_t_EJDB_ERROR_UNIQUE_INDEX_CONSTRAINT_VIOLATED: ejdb_ecode_t = 85006;
#[doc = "< Collection not found"]
pub const ejdb_ecode_t_EJDB_ERROR_COLLECTION_NOT_FOUND: ejdb_ecode_t = 85007;
#[doc = "< Target collection exists"]
pub const ejdb_ecode_t_EJDB_ERROR_TARGET_COLLECTION_EXISTS: ejdb_ecode_t = 85008;
#[doc = "< Patch JSON must be an object (map)"]
pub const ejdb_ecode_t_EJDB_ERROR_PATCH_JSON_NOT_OBJECT: ejdb_ecode_t = 85009;
pub const ejdb_ecode_t__EJDB_ERROR_END: ejdb_ecode_t = 85010;
#[doc = " @brief EJDB error codes."]
pub type ejdb_ecode_t = u32;
#[doc = " Index creation mode"]
pub type ejdb_idx_mode_t = u8;
#[doc = " @brief Database handler."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EJDB {
    _unused: [u8; 0],
}
pub type EJDB = *mut _EJDB;
#[doc = " @brief EJDB HTTP/Websocket Server options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EJDB_HTTP {
    #[doc = "< If HTTP/Websocket endpoint enabled. Default: false"]
    pub enabled: bool,
    #[doc = "< Listen port number, required"]
    pub port: ::std::os::raw::c_int,
    #[doc = "< Listen IP/host. Default: `localhost`"]
    pub bind: *const ::std::os::raw::c_char,
    #[doc = "< Server access token passed in `X-Access-Token` header. Default: zero"]
    pub access_token: *const ::std::os::raw::c_char,
    #[doc = "< Length of access token string. Default: zero"]
    pub access_token_len: usize,
    #[doc = "< Block `ejdb_open()` thread until http service finished."]
    #[doc = "Otherwise HTTP server will be started in background."]
    pub blocking: bool,
    #[doc = "< Allow anonymous read-only database access"]
    pub read_anon: bool,
    #[doc = "< Maximum WS/HTTP API body size. Default: 64Mb, Min: 512K"]
    pub max_body_size: usize,
    #[doc = "< Allow CORS"]
    pub cors: bool,
}
#[test]
fn bindgen_test_layout__EJDB_HTTP() {
    assert_eq!(
        ::std::mem::size_of::<_EJDB_HTTP>(),
        56usize,
        concat!("Size of: ", stringify!(_EJDB_HTTP))
    );
    assert_eq!(
        ::std::mem::align_of::<_EJDB_HTTP>(),
        8usize,
        concat!("Alignment of ", stringify!(_EJDB_HTTP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_HTTP>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_HTTP),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_HTTP>())).port as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_HTTP),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_HTTP>())).bind as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_HTTP),
            "::",
            stringify!(bind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_HTTP>())).access_token as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_HTTP),
            "::",
            stringify!(access_token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_HTTP>())).access_token_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_HTTP),
            "::",
            stringify!(access_token_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_HTTP>())).blocking as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_HTTP),
            "::",
            stringify!(blocking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_HTTP>())).read_anon as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_HTTP),
            "::",
            stringify!(read_anon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_HTTP>())).max_body_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_HTTP),
            "::",
            stringify!(max_body_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_HTTP>())).cors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_HTTP),
            "::",
            stringify!(cors)
        )
    );
}
#[doc = " @brief EJDB HTTP/Websocket Server options."]
pub type EJDB_HTTP = _EJDB_HTTP;
#[doc = " @brief EJDB open options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EJDB_OPTS {
    #[doc = "< IWKV storage options. @see iwkv.h"]
    pub kv: IWKV_OPTS,
    #[doc = "< HTTP/Websocket server options"]
    pub http: EJDB_HTTP,
    #[doc = "< Do not use write-ahead-log. Default: false"]
    pub no_wal: bool,
    #[doc = "< Max sorting buffer size. If exceeded an overflow temp file for sorted data will"]
    #[doc = "created."]
    #[doc = "Default 16Mb, min: 1Mb"]
    pub sort_buffer_sz: u32,
    #[doc = "< Initial size of buffer in bytes used to process/store document during query"]
    #[doc = "execution."]
    #[doc = "Default 64Kb, min: 16Kb"]
    pub document_buffer_sz: u32,
}
#[test]
fn bindgen_test_layout__EJDB_OPTS() {
    assert_eq!(
        ::std::mem::size_of::<_EJDB_OPTS>(),
        144usize,
        concat!("Size of: ", stringify!(_EJDB_OPTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_EJDB_OPTS>(),
        8usize,
        concat!("Alignment of ", stringify!(_EJDB_OPTS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_OPTS>())).kv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_OPTS),
            "::",
            stringify!(kv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_OPTS>())).http as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_OPTS),
            "::",
            stringify!(http)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_OPTS>())).no_wal as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_OPTS),
            "::",
            stringify!(no_wal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_OPTS>())).sort_buffer_sz as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_OPTS),
            "::",
            stringify!(sort_buffer_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_OPTS>())).document_buffer_sz as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_OPTS),
            "::",
            stringify!(document_buffer_sz)
        )
    );
}
#[doc = " @brief EJDB open options."]
pub type EJDB_OPTS = _EJDB_OPTS;
#[doc = " @brief Document representation as result of query execution."]
#[doc = " @see ejdb_exec()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EJDB_DOC {
    #[doc = "< Document ID. Not zero."]
    pub id: i64,
    #[doc = "< JSON document in compact binary form."]
    #[doc = "Based on [Binn](https://github.com/liteserver/binn) format."]
    #[doc = "Not zero."]
    pub raw: JBL,
    #[doc = "< JSON document as in-memory tree. Not zero only if query has `apply` or `projection`"]
    #[doc = "parts."]
    #[doc = ""]
    #[doc = "@warning The lifespan of @ref EJDB_DOC.node will be valid only during the call of"]
    #[doc = "@ref EJDB_EXEC_VISITOR"]
    #[doc = "It is true in all cases EXCEPT:"]
    #[doc = "- @ref EJDB_EXEC.pool is not set by `ejdb_exec()` caller"]
    #[doc = "- One of `ejdb_list()` methods used"]
    pub node: JBL_NODE,
    #[doc = "< Reference to next document in result list or zero."]
    #[doc = "Makes sense only for `ejdb_list()` calls."]
    pub next: *mut _EJDB_DOC,
    #[doc = "< Reference to the previous document in result list or zero."]
    #[doc = "Makes sense only for `ejdb_list()` calls."]
    pub prev: *mut _EJDB_DOC,
}
#[test]
fn bindgen_test_layout__EJDB_DOC() {
    assert_eq!(
        ::std::mem::size_of::<_EJDB_DOC>(),
        40usize,
        concat!("Size of: ", stringify!(_EJDB_DOC))
    );
    assert_eq!(
        ::std::mem::align_of::<_EJDB_DOC>(),
        8usize,
        concat!("Alignment of ", stringify!(_EJDB_DOC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_DOC>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_DOC),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_DOC>())).raw as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_DOC),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_DOC>())).node as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_DOC),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_DOC>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_DOC),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_DOC>())).prev as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_DOC),
            "::",
            stringify!(prev)
        )
    );
}
#[doc = " @brief Document representation as result of query execution."]
#[doc = " @see ejdb_exec()"]
pub type EJDB_DOC = *mut _EJDB_DOC;
#[doc = " @brief Query result as list."]
#[doc = " Used as result of `ejdb_list()` query functions."]
#[doc = ""]
#[doc = " @warning Getting result of query as list can be very memory consuming for large collections."]
#[doc = "          Consider use of `ejdb_exec()` with visitor or set `limit` for query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EJDB_LIST {
    #[doc = "< EJDB storage used for query execution. Not zero."]
    pub db: EJDB,
    #[doc = "< Query executed. Not zero."]
    pub q: JQL,
    #[doc = "< First document in result list. Zero if result set is empty."]
    pub first: EJDB_DOC,
    #[doc = "< Memory pool used to store list of documents"]
    pub pool: *mut IWPOOL,
}
#[test]
fn bindgen_test_layout__EJDB_LIST() {
    assert_eq!(
        ::std::mem::size_of::<_EJDB_LIST>(),
        32usize,
        concat!("Size of: ", stringify!(_EJDB_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_EJDB_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_EJDB_LIST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_LIST>())).db as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_LIST),
            "::",
            stringify!(db)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_LIST>())).q as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_LIST),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_LIST>())).first as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_LIST),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_LIST>())).pool as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_LIST),
            "::",
            stringify!(pool)
        )
    );
}
#[doc = " @brief Query result as list."]
#[doc = " Used as result of `ejdb_list()` query functions."]
#[doc = ""]
#[doc = " @warning Getting result of query as list can be very memory consuming for large collections."]
#[doc = "          Consider use of `ejdb_exec()` with visitor or set `limit` for query."]
pub type EJDB_LIST = *mut _EJDB_LIST;
#[doc = " @brief Visitor for matched documents during query execution."]
#[doc = ""]
#[doc = " @param ctx Visitor context."]
#[doc = " @param doc Data in `doc` is valid only during execution of this method, to keep a data for farther"]
#[doc = "        processing you need to copy it."]
#[doc = " @param step [out] Move forward cursor to given number of steps, `1` by default."]
pub type EJDB_EXEC_VISITOR = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut _EJDB_EXEC, doc: EJDB_DOC, step: *mut i64) -> iwrc,
>;
#[doc = " @brief Query execution context."]
#[doc = " Passed to `ejdb_exec()` to execute database query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EJDB_EXEC {
    #[doc = "< EJDB database object. Required."]
    pub db: EJDB,
    #[doc = "< Query object to be executed. Created by `jql_create()` Required."]
    pub q: JQL,
    #[doc = "< Optional visitor to handle documents in result set."]
    pub visitor: EJDB_EXEC_VISITOR,
    #[doc = "< Optional user data passed to visitor functions."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = "< Number of records to skip. Takes precedence over `skip` encoded in query."]
    pub skip: i64,
    #[doc = "< Result set size limitation. Zero means no limitations. Takes precedence over `limit`"]
    #[doc = "encoded in query."]
    pub limit: i64,
    #[doc = "< Number of result documents processed by `visitor`"]
    pub cnt: i64,
    #[doc = "< Optional query execution log buffer. If set major query execution/index selection"]
    #[doc = "steps will be logged into"]
    pub log: *mut IWXSTR,
    #[doc = "< Optional pool which can be used in query apply"]
    pub pool: *mut IWPOOL,
}
#[test]
fn bindgen_test_layout__EJDB_EXEC() {
    assert_eq!(
        ::std::mem::size_of::<_EJDB_EXEC>(),
        72usize,
        concat!("Size of: ", stringify!(_EJDB_EXEC))
    );
    assert_eq!(
        ::std::mem::align_of::<_EJDB_EXEC>(),
        8usize,
        concat!("Alignment of ", stringify!(_EJDB_EXEC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_EXEC>())).db as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_EXEC),
            "::",
            stringify!(db)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_EXEC>())).q as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_EXEC),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_EXEC>())).visitor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_EXEC),
            "::",
            stringify!(visitor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_EXEC>())).opaque as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_EXEC),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_EXEC>())).skip as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_EXEC),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_EXEC>())).limit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_EXEC),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_EXEC>())).cnt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_EXEC),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_EXEC>())).log as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_EXEC),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EJDB_EXEC>())).pool as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_EJDB_EXEC),
            "::",
            stringify!(pool)
        )
    );
}
#[doc = " @brief Query execution context."]
#[doc = " Passed to `ejdb_exec()` to execute database query."]
pub type EJDB_EXEC = _EJDB_EXEC;
extern "C" {
    #[doc = " @brief Open storage file."]
    #[doc = ""]
    #[doc = " Storage can be opened only by one single process at time."]
    #[doc = ""]
    #[doc = " @param opts  Operating options. Can be stack allocated or disposed after `ejdb_open()` call."]
    #[doc = " @param [out] ejdbp EJDB storage handle pointer as result."]
    pub fn ejdb_open(opts: *const EJDB_OPTS, ejdbp: *mut EJDB) -> iwrc;
}
extern "C" {
    #[doc = " @brief Closes storage and frees up all resources."]
    #[doc = " @param [in,out] ejdbp Pointer to storage handle, will set to zero oncompletion."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_close(ejdbp: *mut EJDB) -> iwrc;
}
extern "C" {
    #[doc = " @brief Executes a query."]
    #[doc = ""]
    #[doc = " The `ux` structure should be configured before this call,"]
    #[doc = " usually it is a stack allocated object."]
    #[doc = ""]
    #[doc = " Query object should be created by `jql_create()`."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = " @code {.c}"]
    #[doc = ""]
    #[doc = "  JQL q;"]
    #[doc = "  iwrc rc = jql_create(&q, \"mycollection\", \"/[firstName=?]\");"]
    #[doc = "  RCRET(rc);"]
    #[doc = ""]
    #[doc = "  jql_set_str(q, 0, 0, \"Andy\"); // Set positional string query parameter"]
    #[doc = ""]
    #[doc = "  EJDB_EXEC ux = {"]
    #[doc = "    .db = db,"]
    #[doc = "    .q = q,"]
    #[doc = "    .visitor = my_query_results_visitor_func"]
    #[doc = "  };"]
    #[doc = "  rc = ejdb_exec(&ux);  // Execute query"]
    #[doc = "  jql_destroy(&q);      // Destroy query object"]
    #[doc = ""]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " Query object can be reused in many `ejdb_exec()` calls"]
    #[doc = " with different positional/named parameters."]
    #[doc = ""]
    #[doc = " @param [in] ux Query execution params, object state may be changes during query execution."]
    #[doc = "                Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_exec(ux: *mut EJDB_EXEC) -> iwrc;
}
extern "C" {
    #[doc = " @brief Executes a given query and builds a query result as linked list of documents."]
    #[doc = ""]
    #[doc = " @warning Getting whole query result as linked list can be memory consuming for large collections."]
    #[doc = "          Consider use of `ejdb_exec()` with visitor or set a positive `limit` value."]
    #[doc = ""]
    #[doc = " @param db            Database handle. Not zero."]
    #[doc = " @param q             Query object. Not zero."]
    #[doc = " @param [out] first   First document in result set or zero if no matched documents found."]
    #[doc = " @param limit         Maximum number of documents in result set. Takes precedence over `limit` encoded in query."]
    #[doc = "                      Zero means a `limit` encoded in `q` will be used."]
    #[doc = " @param pool          Memory pool will keep documents allocated in result set. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_list(db: EJDB, q: JQL, first: *mut EJDB_DOC, limit: i64, pool: *mut IWPOOL)
        -> iwrc;
}
extern "C" {
    #[doc = " @brief Executes a given query `q` then returns `count` of matched documents."]
    #[doc = ""]
    #[doc = " @param db           Database handle. Not zero."]
    #[doc = " @param q            Query object. Not zero."]
    #[doc = " @param [out] count  Placeholder for number of matched documents. Not zero."]
    #[doc = " @param limit        Limit of matched rows. Makes sense for update queries."]
    #[doc = ""]
    pub fn ejdb_count(db: EJDB, q: JQL, count: *mut i64, limit: i64) -> iwrc;
}
extern "C" {
    #[doc = " @brief Executes a given query `q` then returns `count` of matched documents."]
    #[doc = ""]
    #[doc = " @param db           Database handle. Not zero."]
    #[doc = " @param coll         Name of document collection."]
    #[doc = "                     Can be zero, in what collection name should be encoded in query."]
    #[doc = " @param q            Query text. Not zero."]
    #[doc = " @param [out] count  Placeholder for number of matched documents. Not zero."]
    #[doc = " @param limit        Limit of matched rows. Makes sense for update queries."]
    #[doc = ""]
    pub fn ejdb_count2(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        q: *const ::std::os::raw::c_char,
        count: *mut i64,
        limit: i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Executes update query assuming that query object contains `apply` clause."]
    #[doc = "        Similar to `ejdb_count`."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param q           Query object. Not zero."]
    pub fn ejdb_update(db: EJDB, q: JQL) -> iwrc;
}
extern "C" {
    #[doc = " @brief Executes update query assuming that query object contains `apply` clause."]
    #[doc = "        Similar to `ejdb_count`."]
    #[doc = ""]
    #[doc = " @param db        Database handle. Not zero."]
    #[doc = " @param coll         Name of document collection."]
    #[doc = "                     Can be zero, in what collection name should be encoded in query."]
    #[doc = " @param q         Query text. Not zero."]
    pub fn ejdb_update2(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        q: *const ::std::os::raw::c_char,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Executes a given `query` and builds a result as linked list of documents."]
    #[doc = ""]
    #[doc = " @note Returned `listp` must be disposed by `ejdb_list_destroy()`"]
    #[doc = " @warning Getting whole query result as linked list can be memory consuming for large collections."]
    #[doc = "          Consider use of `ejdb_exec()` with visitor or set a positive `limit` value."]
    #[doc = ""]
    #[doc = " @param db            Database handle. Not zero."]
    #[doc = " @param coll          Collection name. If zero, collection name must be encoded in query."]
    #[doc = " @param query         Query text. Not zero."]
    #[doc = " @param limit         Maximum number of documents in result set. Takes precedence over `limit` encoded in query."]
    #[doc = "                      Zero means a `limit` encoded in `query` will be used."]
    #[doc = " @param [out] listp   Holder for query result, should be disposed by `ejdb_list_destroy()`."]
    #[doc = "                      Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_list2(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        query: *const ::std::os::raw::c_char,
        limit: i64,
        listp: *mut EJDB_LIST,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Executes a given `query` and builds a result as linked list of documents."]
    #[doc = ""]
    #[doc = " @note Returned `listp` must be disposed by `ejdb_list_destroy()`"]
    #[doc = " @warning Getting whole query result as linked list can be memory consuming for large collections."]
    #[doc = "          Consider use of `ejdb_exec()` with visitor or set a positive `limit` value."]
    #[doc = ""]
    #[doc = " @param db            Database handle. Not zero."]
    #[doc = " @param coll          Collection name. If zero, collection name must be encoded in query."]
    #[doc = " @param query         Query text. Not zero."]
    #[doc = " @param limit         Maximum number of documents in result set. Takes precedence over `limit` encoded in query."]
    #[doc = " @param log           Optional buffer to collect query execution / index usage info."]
    #[doc = " @param [out] listp   Holder for query result, should be disposed by `ejdb_list_destroy()`."]
    #[doc = "                      Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_list3(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        query: *const ::std::os::raw::c_char,
        limit: i64,
        log: *mut IWXSTR,
        listp: *mut EJDB_LIST,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Executes a given query `q` and builds a result as linked list of documents (`listp`)."]
    #[doc = ""]
    #[doc = " @note Returned `listp` must be disposed by `ejdb_list_destroy()`"]
    #[doc = " @warning Getting whole query result as linked list can be memory consuming for large collections."]
    #[doc = "          Consider use of `ejdb_exec()` with visitor  or set a positive `limit` value."]
    #[doc = ""]
    #[doc = " @param db           Database handle. Not zero."]
    #[doc = " @param q            Query object. Not zero."]
    #[doc = " @param limit        Maximum number of documents in result set. Takes precedence over `limit` encoded in query."]
    #[doc = " @param log          Optional buffer to collect query execution / index usage info."]
    #[doc = " @param [out] listp  Holder for query result, should be disposed by `ejdb_list_destroy()`."]
    #[doc = "                     Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_list4(
        db: EJDB,
        q: JQL,
        limit: i64,
        log: *mut IWXSTR,
        listp: *mut EJDB_LIST,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Destroy query result set and set `listp` to zero."]
    #[doc = " @param [in,out] listp Can be zero."]
    pub fn ejdb_list_destroy(listp: *mut EJDB_LIST);
}
extern "C" {
    #[doc = " @brief Apply rfc6902/rfc7396 JSON patch to the document identified by `id`."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param coll        Collection name. Not zero."]
    #[doc = " @param patchjson   JSON patch conformed to rfc6902 or rfc7396 specification."]
    #[doc = " @param id          Document id. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "         `IWKV_ERROR_NOTFOUND` if document not found."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_patch(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        patchjson: *const ::std::os::raw::c_char,
        id: i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Apply rfc6902/rfc7396 JSON patch to the document identified by `id`."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param coll        Collection name. Not zero."]
    #[doc = " @param patch       JSON patch conformed to rfc6902 or rfc7396 specification."]
    #[doc = " @param id          Document id. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "         `IWKV_ERROR_NOTFOUND` if document not found."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_patch_jbn(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        patch: JBL_NODE,
        id: i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Apply rfc6902/rfc7396 JSON patch to the document identified by `id`."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param coll        Collection name. Not zero."]
    #[doc = " @param patch       JSON patch conformed to rfc6902 or rfc7396 specification."]
    #[doc = " @param id          Document id. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "         `IWKV_ERROR_NOTFOUND` if document not found."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_patch_jbl(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        patch: JBL,
        id: i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Apply JSON merge patch (rfc7396) to the document identified by `id` or"]
    #[doc = "        insert new document under specified `id`."]
    #[doc = " @note This is an atomic operation."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param coll        Collection name. Not zero."]
    #[doc = " @param patchjson   JSON merge patch conformed to rfc7396 specification."]
    #[doc = " @param id          Document id. Not zero."]
    #[doc = ""]
    pub fn ejdb_merge_or_put(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        patchjson: *const ::std::os::raw::c_char,
        id: i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Apply JSON merge patch (rfc7396) to the document identified by `id` or"]
    #[doc = "        insert new document under specified `id`."]
    #[doc = " @note This is an atomic operation."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param coll        Collection name. Not zero."]
    #[doc = " @param patch       JSON merge patch conformed to rfc7396 specification."]
    #[doc = " @param id          Document id. Not zero."]
    #[doc = ""]
    pub fn ejdb_merge_or_put_jbn(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        patch: JBL_NODE,
        id: i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Apply JSON merge patch (rfc7396) to the document identified by `id` or"]
    #[doc = "        insert new document under specified `id`."]
    #[doc = " @note This is an atomic operation."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param coll        Collection name. Not zero."]
    #[doc = " @param patch       JSON merge patch conformed to rfc7396 specification."]
    #[doc = " @param id          Document id. Not zero."]
    #[doc = ""]
    pub fn ejdb_merge_or_put_jbl(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        patch: JBL,
        id: i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Save a given `jbl` document under specified `id`."]
    #[doc = ""]
    #[doc = " @param db        Database handle. Not zero."]
    #[doc = " @param coll      Collection name. Not zero."]
    #[doc = " @param jbl       JSON document. Not zero."]
    #[doc = " @param id        Document identifier. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_put(db: EJDB, coll: *const ::std::os::raw::c_char, jbl: JBL, id: i64) -> iwrc;
}
extern "C" {
    #[doc = " @brief Save a document into `coll` under new identifier."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param coll        Collection name. Not zero."]
    #[doc = " @param jbl         JSON document. Not zero."]
    #[doc = " @param [out] oid   Placeholder for new document id. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_put_new(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        jbl: JBL,
        oid: *mut i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Save a document into `coll` under new identifier."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param coll        Collection name. Not zero."]
    #[doc = " @param jbn         JSON document. Not zero."]
    #[doc = " @param [out] oid   Placeholder for new document id. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_put_new_jbn(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        jbn: JBL_NODE,
        id: *mut i64,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Retrieve document identified by given `id` from collection `coll`."]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param coll        Collection name. Not zero."]
    #[doc = " @param id          Document id. Not zero."]
    #[doc = " @param [out] jblp  Placeholder for document."]
    #[doc = "                    Must be released by `jbl_destroy()`"]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "         `IWKV_ERROR_NOTFOUND` if document not found."]
    #[doc = "         `IW_ERROR_NOT_EXISTS` if collection `coll` is not exists in db."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_get(db: EJDB, coll: *const ::std::os::raw::c_char, id: i64, jblp: *mut JBL)
        -> iwrc;
}
extern "C" {
    #[doc = " @brief  Remove document identified by given `id` from collection `coll`."]
    #[doc = ""]
    #[doc = " @param db    Database handle. Not zero."]
    #[doc = " @param coll  Collection name. Not zero."]
    #[doc = " @param id    Document id. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "         `IWKV_ERROR_NOTFOUND` if document not found."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_del(db: EJDB, coll: *const ::std::os::raw::c_char, id: i64) -> iwrc;
}
extern "C" {
    #[doc = " @brief Remove collection under the given name `coll`."]
    #[doc = ""]
    #[doc = " @param db    Database handle. Not zero."]
    #[doc = " @param coll  Collection name. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Will return `0` if collection is not found."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_remove_collection(db: EJDB, coll: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    #[doc = " @brief Rename collection `coll` to `new_coll`."]
    #[doc = ""]
    #[doc = " @param db    Database handle. Not zero."]
    #[doc = " @param coll  Old collection name. Not zero."]
    #[doc = " @param new_coll New collection name."]
    #[doc = " @return `0` on success."]
    #[doc = "          - `EJDB_ERROR_COLLECTION_NOT_FOUND` - if source `coll` is not found."]
    #[doc = "          - `EJDB_ERROR_TARGET_COLLECTION_EXISTS` - if `new_coll` is exists already."]
    #[doc = "          -  Any other non zero error codes."]
    pub fn ejdb_rename_collection(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        new_coll: *const ::std::os::raw::c_char,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Create collection with given name if it has not existed before"]
    #[doc = ""]
    #[doc = " @param db    Database handle. Not zero."]
    #[doc = " @param coll  Collection name. Not zero."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_ensure_collection(db: EJDB, coll: *const ::std::os::raw::c_char) -> iwrc;
}
extern "C" {
    #[doc = " @brief Create index with specified parameters if it has not existed before."]
    #[doc = ""]
    #[doc = " @note Index `path` must be fully specified as rfc6901 JSON pointer"]
    #[doc = "       and must not countain unspecified `*`/`**` element in middle sections."]
    #[doc = " @see ejdb_idx_mode_t."]
    #[doc = ""]
    #[doc = " Example document:"]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " {"]
    #[doc = "   \"address\" : {"]
    #[doc = "      \"street\": \"High Street\""]
    #[doc = "   }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " Create unique index over all street names in nested address object:"]
    #[doc = ""]
    #[doc = " @code {.c}"]
    #[doc = " iwrc rc = ejdb_ensure_index(db, \"mycoll\", \"/address/street\", EJDB_IDX_UNIQUE | EJDB_IDX_STR);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param db    Database handle. Not zero."]
    #[doc = " @param coll  Collection name. Not zero."]
    #[doc = " @param path  rfc6901 JSON pointer to indexed field."]
    #[doc = " @param mode  Index mode."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "         `EJDB_ERROR_INVALID_INDEX_MODE` Invalid `mode` specified"]
    #[doc = "         `EJDB_ERROR_MISMATCHED_INDEX_UNIQUENESS_MODE` trying to create non unique index over existing unique or vice"]
    #[doc = " versa."]
    #[doc = "          Any non zero error codes."]
    #[doc = ""]
    pub fn ejdb_ensure_index(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
        mode: ejdb_idx_mode_t,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Remove index if it has existed before."]
    #[doc = ""]
    #[doc = " @param db    Database handle. Not zero."]
    #[doc = " @param coll  Collection name. Not zero."]
    #[doc = " @param path  rfc6901 JSON pointer to indexed field."]
    #[doc = " @param mode  Index mode."]
    #[doc = ""]
    #[doc = " @return `0` on success."]
    #[doc = "          Will return `0` if collection is not found."]
    #[doc = "          Any non zero error codes."]
    pub fn ejdb_remove_index(
        db: EJDB,
        coll: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
        mode: ejdb_idx_mode_t,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Returns JSON document describind database structure."]
    #[doc = " @note Returned `jblp` must be disposed by `jbl_destroy()`"]
    #[doc = ""]
    #[doc = " Example database metadata:"]
    #[doc = " @code {.json}"]
    #[doc = ""]
    #[doc = "   {"]
    #[doc = "    \"version\": \"2.0.0\", // EJDB engine version"]
    #[doc = "    \"file\": \"db.jb\",    // Path to storage file"]
    #[doc = "    \"size\": 16384,      // Storage file size in bytes"]
    #[doc = "    \"collections\": [    // List of collections"]
    #[doc = "     {"]
    #[doc = "      \"name\": \"c1\",     // Collection name"]
    #[doc = "      \"dbid\": 3,        // Collection database ID"]
    #[doc = "      \"rnum\": 2,        // Number of documents in collection"]
    #[doc = "      \"indexes\": [      // List of collections indexes"]
    #[doc = "       {"]
    #[doc = "        \"ptr\": \"/n\",    // rfc6901 JSON pointer to indexed field"]
    #[doc = "        \"mode\": 8,      // Index mode. Here is EJDB_IDX_I64"]
    #[doc = "        \"idbf\": 96,     // Index flags. See iwdb_flags_t"]
    #[doc = "        \"dbid\": 4,      // Index database ID"]
    #[doc = "        \"rnum\": 2       // Number records stored in index database"]
    #[doc = "       }"]
    #[doc = "      ]"]
    #[doc = "     }"]
    #[doc = "    ]"]
    #[doc = "   }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param db          Database handle. Not zero."]
    #[doc = " @param [out] jblp  JSON object describing ejdb storage."]
    #[doc = "                    Must be disposed by `jbl_destroy()`"]
    pub fn ejdb_get_meta(db: EJDB, jblp: *mut JBL) -> iwrc;
}
extern "C" {
    #[doc = " Creates an online database backup image and copies it into the specified `target_file`."]
    #[doc = " During online backup phase read/write database operations are allowed and not"]
    #[doc = " blocked for significant amount of time. Backup finish time is placed into `ts`"]
    #[doc = " as number of milliseconds since epoch."]
    #[doc = ""]
    #[doc = " Online backup guaranties what all records before `ts` timestamp will"]
    #[doc = " be stored in backup image. Later, online backup image can be"]
    #[doc = " opened as ordinary database file."]
    #[doc = ""]
    #[doc = " @note In order to avoid deadlocks: close all opened database cursors"]
    #[doc = " before calling this method or do call in separate thread."]
    #[doc = ""]
    #[doc = " @param Database handle. Not zero."]
    #[doc = " @param [out] ts Backup completion timestamp"]
    #[doc = " @param target_file backup file path"]
    pub fn ejdb_online_backup(
        db: EJDB,
        ts: *mut u64,
        target_file: *const ::std::os::raw::c_char,
    ) -> iwrc;
}
extern "C" {
    #[doc = " @brief Get access to underlying IWKV storage."]
    #[doc = "        Use it with caution."]
    #[doc = ""]
    #[doc = " @param db Database handle. Not zero."]
    #[doc = " @param [out] kvp Placeholder for IWKV storage."]
    pub fn ejdb_get_iwkv(db: EJDB, kvp: *mut IWKV) -> iwrc;
}
extern "C" {
    #[doc = " @brief  Return `\\0` terminated ejdb2 source GIT revision hash."]
    pub fn ejdb_git_revision() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return `\\0` terminated EJDB version string."]
    pub fn ejdb_version_full() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return major library version."]
    pub fn ejdb_version_major() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Return minor library version."]
    pub fn ejdb_version_minor() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Return patch library version."]
    pub fn ejdb_version_patch() -> ::std::os::raw::c_uint;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_EXT_IMPL {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWFS_FSM_IMPL {
    pub _address: u8,
}
